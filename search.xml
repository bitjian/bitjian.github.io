<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ts原始基础类型</title>
      <link href="/2020/09/06/%E5%8E%9F%E5%A7%8B%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/09/06/%E5%8E%9F%E5%A7%8B%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="1-js原始基础类型"><a href="#1-js原始基础类型" class="headerlink" title="1. js原始基础类型"></a>1. js原始基础类型</h4><p>原始数据类型的注解包括： 布尔值，数值，字符串，null, undefined</p><h4 id="2-布尔值"><a href="#2-布尔值" class="headerlink" title="2. 布尔值"></a>2. 布尔值</h4><p>1.使用boolean对布尔值进行注解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: boolean = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>2.可以使用Boolen进行类型转换，但不能使用new Boolean构造函数创建, 其他基本类型也一样</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isDone = new Boolean(1) // 报错，new Boolean 返回的是一个Boolen对象的实例</span></span><br><span class="line">isDone = <span class="title class_">Boolean</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="3-数值"><a href="#3-数值" class="headerlink" title="3. 数值"></a>3. 数值</h4><p>1.使用number对数值型进行注解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decNum</span>: number = <span class="number">6</span>  <span class="comment">// 10进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">float</span>: number = <span class="number">6.666666666</span>  <span class="comment">// 浮点数</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexNum</span>: number = <span class="number">0xf00d</span> <span class="comment">// 16进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryNum</span>: number = <span class="number">0b101</span> <span class="comment">// 2进制</span></span><br><span class="line"><span class="keyword">let</span> octalNum = <span class="number">0o766</span> <span class="comment">// 8进制</span></span><br></pre></td></tr></table></figure><h4 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h4><p>1.使用string对字符串类型（包括模板字符串）进行注解</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myName</span>: string = <span class="string">&#x27;Tom&#x27;</span>  <span class="comment">// 普通字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myAge</span>: number = <span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: string = <span class="string">`Hello my name is <span class="subst">$&#123;myName&#125;</span></span></span><br><span class="line"><span class="string">i&#x27;ll be <span class="subst">$&#123;myAge + <span class="number">1</span>&#125;</span> years old next month`</span> <span class="comment">// 模板字符串</span></span><br></pre></td></tr></table></figure><h4 id="5-空值-void"><a href="#5-空值-void" class="headerlink" title="5. 空值 void"></a>5. 空值 void</h4><p>1.void 一般用来表示没有任何返回值的函数返回类型声明</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">alertName</span>(<span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;My name is tom&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="keyword">void</span> = <span class="literal">undefined</span>  <span class="comment">// 没有必要使用void注解，因为它只能被赋值为 null 或者 undefined</span></span><br></pre></td></tr></table></figure><h4 id="6-null-和-undefined"><a href="#6-null-和-undefined" class="headerlink" title="6. null 和 undefined"></a>6. null 和 undefined</h4><p>null 和 undefined 是所有类型的子类型，也就是可以赋值给所有类型<br>1.使用null 和 undefined注解，初始化后只能赋值其本身</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>2.可以将undefined和null 赋值给所有类型</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: number = u</span><br><span class="line">num = n</span><br></pre></td></tr></table></figure><p>在们在 tsconfig.js 文件中设置 为严格模式下，则不能将undefined和void 赋值给自身和void以外的变量了</p><h4 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h4><p><a href="https://ts.xcatliu.com/basics/primitive-data-types.html">原始数据类型</a></p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ts运行环境配置</title>
      <link href="/2020/09/05/ts%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/05/ts%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>最近简单学习了一下ts发现还真有点香，借双休总结回顾一下，先来回顾搭建一个可以运行ts文件的环境，这样后面编译ts就方便了</p><h3 id="1-安装typescript"><a href="#1-安装typescript" class="headerlink" title="1 安装typescript"></a>1 安装typescript</h3><h4 id="1-1-在拥有node的系统环境通过npm安装typescript"><a href="#1-1-在拥有node的系统环境通过npm安装typescript" class="headerlink" title="1.1 在拥有node的系统环境通过npm安装typescript"></a>1.1 在拥有node的系统环境通过npm安装typescript</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure><h4 id="1-2-查看版本检查是否安装成功"><a href="#1-2-查看版本检查是否安装成功" class="headerlink" title="1.2 查看版本检查是否安装成功"></a>1.2 查看版本检查是否安装成功</h4>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tsc --version</span><br></pre></td></tr></table></figure><h4 id="安装成功后就可以通过指令编译ts文件了-会在目录生成对应js文件"><a href="#安装成功后就可以通过指令编译ts文件了-会在目录生成对应js文件" class="headerlink" title="安装成功后就可以通过指令编译ts文件了,会在目录生成对应js文件"></a>安装成功后就可以通过指令编译ts文件了,会在目录生成对应js文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tsc main.<span class="property">ts</span></span><br></pre></td></tr></table></figure><p>感觉老是这样通过指令编译感觉很麻烦，那可以通过webpack配置对应的loader编译ts文件</p><h3 id="2-配置webpack-编译ts"><a href="#2-配置webpack-编译ts" class="headerlink" title="2 配置webpack 编译ts"></a>2 配置webpack 编译ts</h3><h4 id="2-1-创建项目目录"><a href="#2-1-创建项目目录" class="headerlink" title="2.1 创建项目目录"></a>2.1 创建项目目录</h4><blockquote><p>目录结构</p><blockquote><ul><li>src &#x2F;&#x2F;存放源文件<blockquote><p>– main.ts</p></blockquote></li><li>build &#x2F;&#x2F; 存放webpack配置文件<blockquote><p>– webpack.config.js</p></blockquote></li><li>index.html &#x2F;&#x2F; 入口页面</li></ul></blockquote></blockquote><span id="more"></span><h4 id="2-2-初始化npm"><a href="#2-2-初始化npm" class="headerlink" title="2.2 初始化npm"></a>2.2 初始化npm</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><h4 id="2-3-在项目中安装typescript"><a href="#2-3-在项目中安装typescript" class="headerlink" title="2.3 在项目中安装typescript"></a>2.3 在项目中安装typescript</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm -i typescript</span><br></pre></td></tr></table></figure><h4 id="2-4-初始化tsconfig-json文件"><a href="#2-4-初始化tsconfig-json文件" class="headerlink" title="2.4 初始化tsconfig.json文件"></a>2.4 初始化tsconfig.json文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">tsc --init  <span class="comment">// 自动在根目录生成tsconfig.json并初始化配置文件</span></span><br></pre></td></tr></table></figure><p>在配置文件中的lib可以加载额外的模块</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;lib&quot;</span>: [<span class="string">&quot;es6&quot;</span>, <span class="string">&quot;dom&quot;</span>],  </span><br></pre></td></tr></table></figure><h4 id="2-5-安装并配置tslint来约束代码"><a href="#2-5-安装并配置tslint来约束代码" class="headerlink" title="2.5 安装并配置tslint来约束代码"></a>2.5 安装并配置tslint来约束代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm i tslint -g; tslint -i</span><br></pre></td></tr></table></figure><h4 id="2-6-安装webpack相关插件"><a href="#2-6-安装webpack相关插件" class="headerlink" title="2.6 安装webpack相关插件"></a>2.6 安装webpack相关插件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-dev-server -D</span><br></pre></td></tr></table></figure><h4 id="2-7-在package-json-里配置启动脚本"><a href="#2-7-在package-json-里配置启动脚本" class="headerlink" title="2.7 在package.json 里配置启动脚本"></a>2.7 在package.json 里配置启动脚本</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;serve&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --mode=development --config build/webpack.config.js&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-8-安装-cross-env-判断当前是开发环境还是生产环境"><a href="#2-8-安装-cross-env-判断当前是开发环境还是生产环境" class="headerlink" title="2.8 安装 cross-env 判断当前是开发环境还是生产环境"></a>2.8 安装 cross-env 判断当前是开发环境还是生产环境</h4><p>安装cross-env</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install cross-env -D</span><br></pre></td></tr></table></figure><p>在webpack配置文件中判断环境</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">devtool</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span> ? <span class="literal">false</span> : <span class="string">&quot;inline-source-map&quot;</span>,</span><br></pre></td></tr></table></figure><h4 id="2-9-安装webpack-loader-ts-loader-来解析-ts文件"><a href="#2-9-安装webpack-loader-ts-loader-来解析-ts文件" class="headerlink" title="2.9 安装webpack loader: ts-loader 来解析 .ts文件"></a>2.9 安装webpack loader: ts-loader 来解析 .ts文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install ts-loader -D</span><br></pre></td></tr></table></figure><p>在配置文件中配置rule来解析 .ts文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">      <span class="attr">use</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h4 id="2-10-安装-html-webpack-plugin-来配置入口视图"><a href="#2-10-安装-html-webpack-plugin-来配置入口视图" class="headerlink" title="2.10 安装 html-webpack-plugin 来配置入口视图"></a>2.10 安装 html-webpack-plugin 来配置入口视图</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>webpack配置插件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&quot;./index.html&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="2-11-在build文件夹中webpack-config-js-来配置webpack完整配置"><a href="#2-11-在build文件夹中webpack-config-js-来配置webpack完整配置" class="headerlink" title="2.11 在build文件夹中webpack.config.js 来配置webpack完整配置"></a>2.11 在build文件夹中webpack.config.js 来配置webpack完整配置</h4><h4 id="2-12-在src文件夹中main-ts-编写代码或导入模块"><a href="#2-12-在src文件夹中main-ts-编写代码或导入模块" class="headerlink" title="2.12 在src文件夹中main.ts 编写代码或导入模块"></a>2.12 在src文件夹中main.ts 编写代码或导入模块</h4><h4 id="2-13-启动项目"><a href="#2-13-启动项目" class="headerlink" title="2.13 启动项目"></a>2.13 启动项目</h4><p>启动项目，打开地址，和控制台就可以看到ts编译后运行的结果了<br>而不用一个一个文件通过指令编译了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h3 id="完整目录"><a href="#完整目录" class="headerlink" title="完整目录"></a>完整目录</h3><p>目录路径：<br><img src="https://cdn.jsdelivr.net/gh/bitjian/blogImg/2020/09/dirname.png" alt="目录路径"></p><h3 id="完整webpack配置"><a href="#完整webpack配置" class="headerlink" title="完整webpack配置"></a>完整webpack配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/main.ts&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;build.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&quot;.tsx&quot;</span>, <span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.js&quot;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devtool</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span> ? <span class="literal">false</span> : <span class="string">&quot;inline-source-map&quot;</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="attr">stats</span>: <span class="string">&quot;errors-only&quot;</span>,</span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8888</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;./index.html&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/wnL1l-ERjTDykWM76l4Ajw">TypeScript(二)使用Webpack搭建环境</a> </p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js继承</title>
      <link href="/2020/06/13/js%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/06/13/js%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h3><p>  又到了双休，但是手机老是给我提示暴雨预警，哪都不敢去。所以借着这个时机来复习一下js基础中的继承，顺便总结一下中间踩到的坑，每个实例的代码都全部写下来，虽然有很多是重复的但是这样方便查看和理解，如有错误欢迎指点^_^</p><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>原型链继承，就是让子类的原型属性指向父类的实例，这样子类没有在自己的实例里找到属性就会去原型上找（此时是父类的实例），再没有找到就去父类原型上找</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;super&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为父类原型添加方法</span></span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：为子类原型添加方法, 改变子类原型对象后获取不到此方法 ×</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">saySubName1</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;saySubName1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类实例</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Super</span>()</span><br><span class="line"><span class="comment">// 改变子类原型后，为子类原型添加方法 √</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">saySubName2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;saySubName2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayArr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supArr</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类实例</span></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>()</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>()</span><br><span class="line"></span><br><span class="line">sub1.<span class="property">name</span> =<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">sub2.<span class="property">name</span> = <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line">sub1.<span class="title function_">sayName</span>() <span class="comment">// aaa</span></span><br><span class="line">sub2.<span class="title function_">sayName</span>() <span class="comment">// bbb</span></span><br><span class="line">sub1.<span class="property">supArr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>) </span><br><span class="line">sub2.<span class="title function_">sayArr</span>() <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;] -&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>使用原型链继承，可以帮助我们更加深刻的理解原型，但是也有很多缺点<br>缺点，1.修改父类引用类型，所有子类实例都会受到影响<br>2.不能实现多继承 3.不能向父类构造函数传参</p><span id="more"></span><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><p>构造函数继承就是在子类的构造函数中通过call或apply方法，调用父类构造函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为父类原型添加方法,通过构造函数继承，子类并不能获取到父类的原型</span></span><br><span class="line"><span class="comment">// Super.prototype.sayName = function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.name)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Super.prototype.sayArr = function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.supArr)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 通过 call 或者 apply 调用父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayArr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supArr</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;zzj&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;sjj&#x27;</span>)</span><br><span class="line">sub1.<span class="title function_">sayName</span>() <span class="comment">// zzj</span></span><br><span class="line">sub2.<span class="title function_">sayName</span>() <span class="comment">// sjj</span></span><br><span class="line"><span class="comment">// 在 sub1里push c</span></span><br><span class="line">sub1.<span class="property">supArr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// sub2里的arr不会受到影响</span></span><br><span class="line">sub2.<span class="title function_">sayArr</span>() <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure><p>在这里本能的去父类原型上写方法，但是在调用的时候并获取不到父类的方法，<br>这是因为在子类通过call调用父类构造函数时，只是拷贝了父类中实例的属性<br>优点：1.可以向父类构造函数传参， 2. 引用类型不会受到其他实例的影响<br>缺点：1. 定义的方法不能复用，每个实例都会重新定义原型上的方法</p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承是结合原型链继承和构造函数继承，弥补了原型链继承不能传参和引用类型的改变会影响到其他实例，也弥补了构造函数继承只能在子类中定义方法，每个实例都会重新定义一次方法的缺点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为父类原型添加方法</span></span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 call 或者 apply 调用父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 第二次调用</span></span><br><span class="line">  <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类实例</span></span><br><span class="line"><span class="comment">// 第一次调用</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Super</span>()</span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayArr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supArr</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;zzj&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;sjj&#x27;</span>)</span><br><span class="line">sub1.<span class="title function_">sayName</span>() <span class="comment">// zzj</span></span><br><span class="line">sub2.<span class="title function_">sayName</span>()  <span class="comment">// sjj</span></span><br><span class="line"><span class="comment">// 在 sub1里push c</span></span><br><span class="line">sub1.<span class="property">supArr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// sub2里的arr不会受到影响</span></span><br><span class="line">sub2.<span class="title function_">sayArr</span>() <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>虽然弥补了缺陷，但是子类调用构造函数时通过call拷贝了父类上的实例属性，然后子类又通过原型指向了父类的实例，那么子类原型上又有了父类上的实例属性。<br>优点： 1.结合了 原型链继承 和构造函数继承，弥补了各自的缺陷<br>缺点： 调用了两次父类构造函数，导致子类实例和原型上都有父类实例上的属性</p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>原型式继承，就是基于已有对象，创建一个新对象和Object.create类似</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Object</span>(<span class="params">sup</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个中间函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 将函数的原型指向sup</span></span><br><span class="line">  <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = sup</span><br><span class="line">  <span class="comment">// 返回函数的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;super&#x27;</span>,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sayArr</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">arr</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">Object</span>(person)</span><br><span class="line"><span class="keyword">let</span> newObj2 = <span class="title class_">Object</span>(person)</span><br><span class="line">newObj.<span class="property">name</span> = <span class="string">&#x27;newObj&#x27;</span></span><br><span class="line">newObj2.<span class="property">name</span> = <span class="string">&#x27;newObj2&#x27;</span></span><br><span class="line">newObj2.<span class="title function_">sayName</span>() <span class="comment">// newObj2</span></span><br><span class="line">newObj.<span class="title function_">sayName</span>() <span class="comment">// newObj</span></span><br><span class="line"><span class="comment">// 修改 newObj里的数组会影响到其他实例</span></span><br><span class="line">newObj.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>) </span><br><span class="line">newObj2.<span class="title function_">sayArr</span>() <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure><p>缺点和原型链继承一样</p><h4 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h4><p>结合上面三个，将子类的原型指向通过Object函数创建的中间函数的原型，因为中间函数没有实例属性，这样子类原型上就不会有父类属性，这句话看代码就理解啦。中间我产生了一个疑问为什么不直接让子类原型指向父类原型呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型式函数,创建一个中间函数,让中间函数的原型指向父类原型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ObjectCreate</span>(<span class="params">sup</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = sup.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生函数,对子类操作的封装,主要是来弥补子类原型构造函数的缺失,和让子类构造函数指向中间函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inherit</span>(<span class="params">sub, sup</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="title class_">ObjectCreate</span>(sup); <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = sub; <span class="comment">// 增强对象</span></span><br><span class="line">  sub.<span class="property"><span class="keyword">prototype</span></span> = prototype; <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">supArr</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为父类原型添加方法</span></span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 call 或者 apply 调用父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Super</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：定义子类原型方法不能在 寄生组合继承操作之前， 因为子类的原型指向被改变了</span></span><br><span class="line"><span class="comment">// Sub.prototype.sayArr = function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.supArr)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类实例</span></span><br><span class="line"><span class="comment">// Sub.prototype = new Super()</span></span><br><span class="line"><span class="comment">// 不采用上面的方法，采用寄生原型式</span></span><br><span class="line"><span class="title function_">inherit</span>(<span class="title class_">Sub</span>, <span class="title class_">Super</span>)</span><br><span class="line"><span class="comment">// 疑问？ 为什么不直接让子类原型直接指向父类原型呢</span></span><br><span class="line"><span class="comment">// 因为这样实例修改了或增加的原型上的属性，那么原型就改变了会影响到其他实例</span></span><br><span class="line"><span class="comment">// Sub.prototype = Super.prototype</span></span><br><span class="line"><span class="comment">// 定义子类原型方法应该在寄生组合继承操作之后</span></span><br><span class="line"><span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayArr</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">supArr</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;zzj&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="string">&#x27;sjj&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sub1.<span class="title function_">sayName</span>() <span class="comment">// zzj</span></span><br><span class="line">sub2.<span class="title function_">sayName</span>()  <span class="comment">// sjj</span></span><br><span class="line"><span class="comment">// 在 sub1里push c</span></span><br><span class="line">sub1.<span class="property">supArr</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">// console.log(sub1)</span></span><br><span class="line"><span class="comment">// console.log(sub2)</span></span><br><span class="line"><span class="comment">// sub2里的arr不会受到影响</span></span><br><span class="line">sub1.<span class="title function_">sayArr</span>()</span><br><span class="line">sub2.<span class="title function_">sayArr</span>() <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>优点： 完美<br>缺点： 踩的坑有点多， 1.在Object函数中 应该是将父类原型赋值给 中间函数，而不是父类构造函数， 2. 定义子类原型方法应该在寄生组合操作之后</p><p>掌握到这些，那js的继承应该就差不多了，不过现在我更喜欢ES6的class中extend继承，但是这些理解了，有木有感觉自己又变强了^_^</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-html中的dom绑定事件</title>
      <link href="/2020/05/10/v-html%E4%B8%AD%E7%9A%84%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/05/10/v-html%E4%B8%AD%E7%9A%84%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>后台返回数据为HTML，通过v-html渲染页面后，jquery为数据里的Dom添加事件</p><h4 id="后台数据与渲染"><a href="#后台数据与渲染" class="headerlink" title="后台数据与渲染"></a>后台数据与渲染</h4><p>这是后台返回的数据 <img src="https://cdn.jsdelivr.net/gh/bitjian/blogImg/2020/05/data.png" alt="后台返回的数据"><br>这是通过v-html渲染到页面 <img src="https://cdn.jsdelivr.net/gh/bitjian/blogImg/2020/05/html.png" alt="渲染到页面"></p><h4 id="添加点击事件失败"><a href="#添加点击事件失败" class="headerlink" title="添加点击事件失败"></a>添加点击事件失败</h4><p>在vue声明周期mounted添加事件,并没有添加到，甚至连dom都没有获取到</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="string">&#x27;.app-link&#x27;</span>))</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;.app-link&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1111111111&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><span id="more"></span><p>在mounted里使用 setTimeout也没有用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      $(<span class="string">&#x27;.app-link&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1111111111&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>通过一番倒腾，最终在updated里添加事件成功</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">updated</span>(<span class="params"></span>) &#123;</span><br><span class="line">      $(<span class="string">&#x27;.app-link&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">      event.<span class="title function_">preventDefault</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1111111111&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>最好在beforeUpdate里清空要添加dom的点击事件，不然每次执行updated，都会在click事件里添加一个function</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;.app-link&#x27;</span>).<span class="title function_">off</span>();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于for的一系列</title>
      <link href="/2020/04/24/%E5%85%B3%E4%BA%8Efor%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/"/>
      <url>/2020/04/24/%E5%85%B3%E4%BA%8Efor%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>遍历数组常用for循环 ES5遍历数组的方法有forEach,map,filter,some，every,reduce等<br> 使用forEach不能使用break和return跳出循环</p><p>es5的forEach方法其实性能比for循环还要弱，使用for循环可以将长度用遍历存起来，可以优化性能</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> myArray = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>];</span><br><span class="line">myArray.<span class="property">name</span> = <span class="string">&quot;数组&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>,len = myArray.<span class="property">length</span>; j &lt; len; j++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p>使用for in 遍历数组的毛病</p><p>1.index是字符串<br>2.遍历顺序可能不是数组的内部顺序<br>3.会遍历数组的可枚举对象包括原型，例如上面的method和name<br>所以for in 不适合遍历数组</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index,myArray[index])</span><br><span class="line"><span class="comment">//   0 a</span></span><br><span class="line"><span class="comment">//   1 b</span></span><br><span class="line"><span class="comment">//   2 c</span></span><br><span class="line"><span class="comment">//   3 d</span></span><br><span class="line"><span class="comment">//   name 数组</span></span><br><span class="line"><span class="comment">//   method function() &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.length)</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h5><p>使用for of 遍历的是数组的值而 for in 遍历的是数组的键名<br>for of遍历只会遍历数组自身的值，而不会去遍历原型和其他属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><h5 id="1-使用for-in遍历对象"><a href="#1-使用for-in遍历对象" class="headerlink" title="1.使用for in遍历对象"></a>1.使用for in遍历对象</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&quot;banane&quot;</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&quot;cherry&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> myObj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i,myObj[i])</span><br><span class="line"><span class="comment">// 会遍历到原型上的方法和属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line"><span class="comment">//   method function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(this)</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想遍历原型上的方法和属性可以使用hasOwnPropery<br>hasOwnPropery可以判断某属性是否是对象的实例属性，从而过滤掉原型上的属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> myObj) &#123;</span><br><span class="line">  <span class="keyword">if</span>(myObj.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i, myObj[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只获取自身属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="for…of-1"><a href="#for…of-1" class="headerlink" title="for…of"></a>for…of</h5><p>也可以使用for of 搭配Object.keys 来遍历对象 返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).<br>相关的Object属性还有<br>Object.getOwnPropertyNames(obj) 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性).<br>使用Reflect.ownKeys(obj)遍历 返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举.  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(myObj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, myObj[key])</span><br><span class="line">  <span class="comment">// 不包含原型属性</span></span><br><span class="line"><span class="comment">//   a apple</span></span><br><span class="line"><span class="comment">//   b banane</span></span><br><span class="line"><span class="comment">//   c cherry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实在想用 for of遍历对象，可以给该对象添加Symbol.iterator迭代器接口<br>接口自己实现<br>for of循环会先调用集合的Symbol.iterator方法，然后返回一个新的迭代器对象，<br>迭代器对象可以是任意具有next方法的对象，迭代器对象会重复调用这个方法<br>每循环一次调用一次<br>迭代器对象可以是任意具有next方法的对象，迭代器对象会重复调用这个方法var<br>使用Genertaor 自带next()</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myObj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">a</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实现一个简单的迭代器</span></span><br><span class="line">myObj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(self);</span><br><span class="line">  <span class="keyword">const</span> len = keys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> done = pointer &gt;= len;</span><br><span class="line">   <span class="keyword">const</span> value = !done ? self[keys[pointer++]]: <span class="literal">undefined</span>;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     done,</span><br><span class="line">     value</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> myObj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用for of 遍历Map对象 顺便回顾一下Map对象的基本使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;apple&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;banane&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;c&quot;</span>, <span class="string">&quot;cherry&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 给Map对象添加属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">set</span>(<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;durian&#x27;</span>)) <span class="comment">// 返回是添加之后的Map</span></span><br><span class="line"><span class="comment">// 判断key是否存在 返回值 是否存在</span></span><br><span class="line">myMap.<span class="title function_">has</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myMap.has(\&#x27;a\&#x27;): &#x27;</span>, myMap.<span class="title function_">has</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// myMap.delete(&#x27;a&#x27;) // 删除属性 返回值 是否删除成功</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myMap.delete(\&#x27;a\&#x27;): &#x27;</span>, myMap.<span class="title function_">delete</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// myMap.get(&#x27;d&#x27;) // 获取属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;myMap.get(\&#x27;d\&#x27;) : &#x27;</span>, myMap.<span class="title function_">get</span>(<span class="string">&#x27;d&#x27;</span>) );</span><br><span class="line">使用数组结构 <span class="title class_">Map</span>的item</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>for of 使用于遍历数组&#x2F;数组对象[{},{}]&#x2F;字符串&#x2F;map&#x2F;set等有迭代器对象的集合<br>但不能遍历对象，应为对象没有迭代器对象,它可以正确的相应break、continue、return语句<br>es5的forEach方法其实性能比for循环还要弱，使用for循环可以将长度用遍历存起来，可以优化性能</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/zjx304/p/10687017.html">for in 和for of的区别</a><br><a href="https://blog.csdn.net/kuangshp128/article/details/85342343">ES6可迭代对象与迭代器的理解</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅拷贝与深拷贝</title>
      <link href="/2020/04/22/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/04/22/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="使用Object-assign将原对象的值分配给一个新对象"><a href="#使用Object-assign将原对象的值分配给一个新对象" class="headerlink" title="使用Object.assign将原对象的值分配给一个新对象"></a>使用Object.assign将原对象的值分配给一个新对象</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span></span><br><span class="line"><span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要在Object.assign 重新定义一个&#123;&#125; 然后将obj复制到&#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> objCp = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj)</span><br><span class="line"><span class="comment">// 修改objCp 的属性 不会影响原来的对象</span></span><br><span class="line">objCp.<span class="property">age</span> = <span class="string">&#x27;23&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCp, obj) <span class="comment">// &#123; name: &#x27;zzj&#x27;, age: &#x27;23&#x27; &#125; &#123; name: &#x27;zzj&#x27;, age: &#x27;22&#x27; &#125;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="使用ES6的扩展运算符"><a href="#使用ES6的扩展运算符" class="headerlink" title="使用ES6的扩展运算符"></a>使用ES6的扩展运算符</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objCp = &#123;...obj&#125;</span><br><span class="line">objCp.<span class="property">age</span> = <span class="string">&#x27;23&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCp, obj) <span class="comment">// 效果同上</span></span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h5 id="使用使用Json-parse-Json-stringfy-缺点：不能拷贝源对象中-undefined-值和-方法"><a href="#使用使用Json-parse-Json-stringfy-缺点：不能拷贝源对象中-undefined-值和-方法" class="headerlink" title="使用使用Json.parse(Json.stringfy()) 缺点：不能拷贝源对象中 undefined 值和 方法"></a>使用使用Json.parse(Json.stringfy()) 缺点：不能拷贝源对象中 undefined 值和 方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">girlFriend</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能拷贝方法 和 undefined</span></span><br><span class="line"><span class="keyword">let</span> objCp = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">objCp.<span class="property">name</span> = <span class="string">&#x27;sjj&#x27;</span></span><br><span class="line">objCp.<span class="property">age</span> = <span class="number">23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCp, obj)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;sjj&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125; &#123; <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">girlFriend</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">getName</span>: [<span class="title class_">Function</span>: getName] &#125;</span><br></pre></td></tr></table></figure><h5 id="编写一个深拷贝函数"><a href="#编写一个深拷贝函数" class="headerlink" title="编写一个深拷贝函数"></a>编写一个深拷贝函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个函数</span></span><br><span class="line"><span class="comment">// 1. 判断传入的值是否是 对象 如果是进行拷贝，否则直接返回</span></span><br><span class="line"><span class="comment">// 2. 判断传入的值 是对象还是数组 给该值初始化&#123;&#125;或者[]</span></span><br><span class="line"><span class="comment">// 3.进行递归</span></span><br><span class="line"><span class="comment">// 深拷贝函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCp</span>(<span class="params">data</span>) &#123;</span><br><span class="line"> <span class="comment">// 判断是不是&#123;&#125;或者Array</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span> &amp;&amp; data) &#123;</span><br><span class="line">    <span class="comment">// 判断该值是对象还是数组</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="keyword">typeof</span> data.<span class="property">length</span> === <span class="string">&#x27;number&#x27;</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="comment">// 进行递归，对子项进行判断</span></span><br><span class="line">      val[item] = <span class="title function_">deepCp</span>(data[item])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">girlFriend</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objCp = <span class="title function_">deepCp</span>(obj)</span><br><span class="line">objCp.<span class="property">name</span> = <span class="string">&#x27;sjj&#x27;</span></span><br><span class="line">objCp.<span class="property">age</span> = <span class="number">23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objCp, obj)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;sjj&#x27;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125; &#123; <span class="attr">name</span>: <span class="string">&#x27;zzj&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">girlFriend</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">getName</span>: [<span class="title class_">Function</span>: getName] &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019回顾</title>
      <link href="/2019/12/29/2019%E5%B9%B4%E6%9C%AB/"/>
      <url>/2019/12/29/2019%E5%B9%B4%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="3888b68efd3616a1ddf46939fc54d4f673fdc23b0671b747a78ab7e189cfad71">305a832858cf8cef14f9d85cee8e5b9d3fe10307103af5ee275a8dd34365887ac622e8adf4ecd33650182a9c1e04f5a0acaeaf8bc0979aa8190f9abedcff3d47216e893613386a547ccf7b792fdae105ec00966040c2ccca50f09891d886d3b2635faf2fe6a40d1680af5a102d1a07c3f98328413fd28476f616ccf71cab2619fd13a0c9688605ba8bc1db6935a25678a93a834cbe5fe4295597af8ecaeddee50a2ac8f14ebef46ad1ac82ca5a182e9291de693ce66b64db9f84646ba54b6f482c6d1998cb5888a94b7c7f70e1e37a19514482eb001ac94b7e1d964cc7732c1e6ae677a6554225cf912382acd6af40916b8c462da928f41e1b32691d92bc12fbda1bf9771cf1eb2e86f115a5308fce28c9fbb9d514fef113178a43c8a2835c45046062f4f187405c223431765044840b2d3ed64b25524e13f8e39028d73a6814ecfdacb7309dee83da23f58c75e53df2cafe1657a35a0c67c3b5f1c6533c72955eb0baaf0e536116146b3cc1dff05d1a8a865278516bec48972c00df5c53bd6a7aaef71d9edf5e89659986ab2f6f1debfa3c886989a05fc42ed14f10ff709aedb15d7e4df95985a186e8ba79171bb90ecadb5758f01ffccbcc6702f828961b763385e552025ccc2946457126a825b2807be6a21c25b06f4ec63fe022c9aaaf899dbb33adbe162f14af0819e4272709af3f779732a7b8a5cad2cd370e4458971e77f7d1edab1f7f0b891e685f281077ae857b88a0cb51dde8308b19548264f8e96b680eb992f6536f278b6b6d909f8f176132273227eb4834ee13b3a63c1d891bf1d9bc16e61e95233f0045e0866f8f5285033afa06a197f72fa980c8d54b5ad39b1867eb8215d8b3f28d806baee0a1b91f9e8eaf920d9d37ff26bcc4f78bafed2420d6932f301b4f96d4d232092ef1a28381493693d11fa4c866fb88139cc05cefb97ffaf4e64cf2110defb2ab6ff3a0cfb51a4d51c88a4beb868f18726a836aec2871925be27af5138b37a4864fab5b96987516b6f05eaacfd224c24fb672c3c96e6d2f528d9e6dca4a0c26104b8896ebc1ef63278e6d64b7ab326dd8b2bab8fe07cf1d0313ed27061f2e0aa52cdabc4b616b3a75b9bec484d5fcf1a1b646295423779c1e821af152c0245c6613b69df5a390fda0225b994971eef1d77b63b9e1d0b91bca3b39b9384418bcb78147189db9b036ca3c79525c307d1ca4f059b4847b04520356789c11b3e83cd54e0b876710450ec00954cc7db0f25f6d72f7f017b8590a603040560e89504abd2851cc5a0b1a64b890249f3e35651f38cb7efa6ad2ab29b11cf08704c4fd66a7ed49852892abf0da5fa0fc1e3036c93fa092eba888bfca51bcc4259011ce002f2745f3b89b193abcd338bc4f63632589352fcd428ddf43f7a8d6960f1f028cde85dcf4444c6ab8cac20d0b6fdc919cb6249f6834ac71942657ebf708f54ae86a9f911ad3ff3331662a753a68eed0cce0a61369840c5e4b127302519d7157ffb403b4f0e218111acd72ac24e4ceab73b86307b499f129ac5b18c393dc8d41b614045529a539668290eba434cc1bae189dcd46ad149b4f45c2551af26dfe30c1c8bc0ffe2cb2a5a3c722f5a55b0f21298b12f15b10341227f8dd3a7988be2182a18b7b8ee14499f9ee1873644c89ee08fd1f7da13973f1f2eacfa180c2f833c7747559affc0930410f356b89e491dfbdc893b58511747adeb02b3d39b6c176d2867ba4c172e90855d41b4cce90f543cf83f0946b016ced7ac04afd46d4edb3c4942e24d02bdf3e9a3310a070a1daa00d4fdf1ef7788ba9ff7696f93d36e782f366f5966644bf66427fb94bc0527753bba163089aaaef894191518c35404b1ac75d8bc38433ff2bb877d8ec6e757082aa6577dbe065344552aee2eee75936cff8563ba8b15a6f3e48af902ef1ff6d39a337df26af76ee82eb6d47489a0ab3fc563316db5fcd7adde60662e5918ecdc5c8229241a44e2530015e88e37ebad126e3b202ddc0770d1ce9065f708a431b30b0cc54ebf082a55e8b6271ff16908dfb60e6db9b022cc51815a3969210cdd91823cae252f85e9490e33a272e85f0c9fd20f6f7317d4e535f70bf67f07b1f2e504d9aaadda28cd7174ae75fabe6cdf50071c01ed12d922fa2ceba9bec12bbfb23a0b6ad2a9b69d31a8e22ff6f14e9f711e61df074bfc498811105d68b679288fc9b6fbed8a559ac50ae8da8b6990dd762a689ba5778e0b288d9e82c6fa341bb5e77e4223d0b4e0a0b59f2321a15acec38f94a376135df71787c6b7a06ab4322d0b0662215a351a79a41d888d73481907ef8780aaf2169fa840fecf9551644e39b6024b7e484749f0ca1bce2ec1d9e4a1b8c28abd1a97768da66206c010b2259af37f7274d962c71490581519a078e6dc2b0026636e81fd82334ef5d82565833f43ea6a6ea6697293dbe3dad778a21b98df6b7cf34f48d15ab042612bd79020eeee9c8dc8aae5384a65617dd586d1f08526d8616c5ffcfc1440dabcf3a87fb2a52b2b92adb8d6831ae79915b55a265e9a8c22fa39ea22f3fa760fdb2cf86f0925de4f2d46e7654b335be887cc68ccddb1cfe46daa75451532cf1e9675d7e9dd3a4e7199aabce85d69ffd5a7f6212f99fc6176f89ccecd4fe5d975406c16e863252bc674679dce65d4ad364bf9eaf5e036c45a3ee3be5ea4a287811242cf0c78aef417c5b63231b9704c8b38fdb06a6ed5177c5dabe643369ac89073103735c4822efeddf7bdf13f6f266197cceaf5396b866ce5b6dc5a2c87cd23438df12ab34f237044e8d0cd0d58863586202c7c67201ac5bc743e281e13551c90545a154a807f3b23b9ffdd528990838126dd508febfa48764f6d2c33da3283bd3e4584572a5e1b5eae24f33a293c456f41c4259dadbad5419f63e7e157b0abb00b1d4eac1453a792555b2035a0d0d6bcb2fe1c847021d0d75ca36fdf95415804fc3e109fb174b7d90e9f693ea2163e6821c61ae5e2062d0afe1fbd663dc8b8c1fc31955ce4bebad0a66b99e97ff41f1dc5ad6969ddc674ad038ed3699d969300732b2e93c6cee46bd6e69d30826da3576dfc406a2aa473ab710c29ba4a993bb198c675f29203c9dd61f22da57e268c5001823851759dc4d1b7488186801423e259058c9e692f5f464f05ac1e49762341cb134862d043d25a66f80a954b7332f6a4e286d3fd9c549e15f0838005ef093805cd287c7f6b102c21c8f6f8776c316f5d55765d032b50c914e6a9548605abd7b426b41958e6fa7a79b34292c0194c88484e0cc4b7a3170ca70be1545e258e3610a3c50613ab0e8880015e476f1934d23609ed6fd85495f94556a32dd71de73584b45c40e33a2f511b2df8a7ca4db4374fb2078f063be300e7236de8453be1a9e71060f85883b6f587eb7e905813168cb6f0146f72864cf70d1fe2d517e6bc1e7ec66478c204791d923bbe782dba883ceede038ef55ba145da996dbfebcee5e28078579fb465a27f4a266d65b720f33416e8e7b04ee9b7ff378235e6c4d8da9d362ed8b48572a08b9625706527dea1aafd3864d87e90d2e305cc83b41eb621730e6a0e6d8c271cdd9bc996f30a4ca12afeacf8e579956a56d55cdea3fb7a7f7e9cefa949531cbf03d3a9a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辞职辞后感</title>
      <link href="/2019/10/21/%E6%AF%95%E4%B8%9A%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BE%9E%E8%81%8C/"/>
      <url>/2019/10/21/%E6%AF%95%E4%B8%9A%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%BE%9E%E8%81%8C/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="4fbbb8fe7b39f00c68d1ffa0e62f56672e6990da33780cf74ce30840041bfc0c">305a832858cf8cef14f9d85cee8e5b9d20303923c5e2ad35473531b46facdf7118e1d2155e6ef61c2d4fe32f327b39bf8ccd06ee4c237e3e1a9ee9030e9b1be4bbf9fa5746f5500a7482651030ea9f89562b85cf933a3ca52e91cde4496fdb507803101803070c929f99a5bd80316d6a61c9209149244f55cab93b3f8d6bc4ddae6faf3d402a7477a627ed1ecf62037b4cbc43c40db76426def49f0021ed26434c5b2d93a68c48c85487b9a0b370a80c84c206b7c530cf6f219738507bab3a2670416cdc09d3e07d9e3b6f52783ede13ded2d022b2125cc520123f33e6e268382eea975432c9aee3f249d62bd6f4acec785b610dbe68a1fd00f838cccaa6326df87175320d116adda6f37e7b21460138f1320498202e8c08275db5a75696238aa3d3d07f07c4baa916b912dad44246cd8c1dcf649a7b690eb9df1b17f9c0159bfc8908a4b450d0d9c29ebbde6f549b0a81c5c32ff14ef81d10afb64cf088f7ac0b5aa5ac745730b896f57a27e2727c932ed13ab98b5b56899a85fd71f961dd6b73477074268673ed833613391647416c8541dc2d137d2cb8e5de1662487f5019590b438a48859739a25e460c70537e55cd6e235ba500029af273ff95b03a33a57130cfc3ca6d3fe23c93698689e7d54cb0ac8482ca5ce1047703950000907b96ff93be6a20f7e160473361678e6244c99f36878194a9d4dae9880c0f97469e162fb85cc453467aba1f6b919510e52073e994480abeceda58928b08cdf1f2eb9d00b0b18d6bb51e491aa9a37bbaa4aff78a57c4bf16eaeb0140e1ebf4067bd05f484948d1de633be41941f56d5587e9db8dea66e1ff50a289c78e32df4502159dc9ba78dae372ed7495080331966bd366e6922753c42b2ef70ef6457195af40e07d8023c228b5eb092dd552832879bbbaefb162a0b11a56c0c0eaf8fc8405ace2a166fa66a88c067dcc9f0d33c097db710cdaef521f6c6c29a594a39ff844010a019984ac0d6580d12f259df7ad8e6ef75ab0fc9eb6c933179de58b4cb9624b4d2705f64c4348b69c77b90510c488f3b464daab6be61f8758f1672f6632462ca6832d9c423a3c31af87a8b628a578ffb01c357388f2a91eec0faf1abe1903d206cab4eb632c45495bea9efa5f60b63eed583d17aaaef1eb0fc4df70d67d0a48b3f4612056371dc07c549394dfa729b758fce2002fb0524d44b0e1e4e14cce320df7f8c7147bc74d48c368532160d6cff9230fab8c2b76d76e038adf604c748cdd69ca8880c4dcf0ba38b841fdee2745754209073417260eae9785fa570b71ce69404691703845eda786dec939eeaf58d9a0da67408a15de67d4069d5127c57eda3032738a02a934705bbf16b898dceabc6ea780bf07c140e2fe4fdabb28a94aa1ef4ab214c983b28ad271c60f5328d5f9a08237d9502a65d4d3139e47cdac200db38c5f181c606199d62d0b33d9808cfb6310a70e2745a84433a521828060f7398c1c9eb5ecb80a91ae6a1fe5ff6cbc632bd44bb0befffb67d48e40dfa1b00bc16074a8637ded5c04446c7cf503efa996611e0c31c6628347bde011acdbcf7af696b06fd25eea51736f20d697c9479c04cb25c7f6068cdf3d7ad072e23e258b7cd172ef060c81309e752d15cec206a4eef2c2f0224237352cdebfed88d35b767b3c09d0f8f00994697cb17d90be7071c40ce0a6c64001d5f09f3ca35f5cceffdf2c0eada7c50ef317c46dee4091131871458b785daedbf265fe0be6caac7092787e13f349fb683650b3ea8e8e9d62feb57185099692b0cbe16f6d8d8b82d7a0729f43f3e607419821bc567cec73f9864f1a817f9baa78a766bd52d22a1455a13d9dcee634fc43f9796de90def58d98f62a3825aaa9bdb41cffb13ed3e33d10a7a85999f72a1a9ba4458b2d778ac332a91f40669c478c03b3ecd7651584039d15c643dbcbd5810a8da8d26e5ed0bec21b96636928dbc7feaa04479c9067e32fbb3f1190102a094d6894c8f895f680d98a84abc1a4d7fc2242aa009e8a3e0ad1ee4984b72492c7350ddb48e61ca039bec5f31b8fd4a1797eab955e05ac44e8580db4918b650d2e45b0abbd08e2501150aa5e1800a61342da7a1ba5121d36d3d16557e8e6f374fb05416d9a732a27bd5898cb4dc44faee15689bb4920a53fe2608078921d3a0f1be94dc76ee2e59b5d82a913c4fbc24de2cae2f464941ed079f3e69bfdfba1d577f79a7d1934367f66975ccaa005b4f7c30983f6f1ad1a4ff205e6f88fc22ae1dee22a7e3d91a3d52031607ab38dfa1dbebcca92482ce9ae78050656761a204aa6f249dc0f6761fc6cd1f1684ba3877af9d04efd43fdb3b0bc3c6f0c325848d92d7fcb3e20dd51dbc41445b6859695e1d24b693053ba67ff4077457999009d133775e0611f74ee0ef4fcb990cf30d08b8c92c5b8e06871477d3bed606a1352b79d712fb8ef617fe82d2f78020e817ba65c67b3ee37f8dedbbea7f6368326ab18899a6148eee62931f0b50e544f0a9925800ebaff80c8ae137729d7b869c6baf9228bddf7420bd6f102d154e74c659abbba6baf71ced3c1b329b28a8d241d5c5dc3cf6580ad66ad2ddd8c82f3bd1caa7b55031ddd5872f9a48af386a270d84ed3ccd34aea87a842ead5fedff406b5e39a687ea00a9348bfa4a7efc74d7243212f6dcb2ff5561b8c56b4a7ab1d87ad89696c035d845fca18f0f704c64b03c4d61d53c71f8f1647bd343a5b7944de6cb40b84505417a0baf96850273ee0e054ddcf40a80e33f21d109680c8dfb935a65d13261e6b51db4a4a85ef6b51ed2103d6c4b7b6e0fc83ae6d5c5c4d97ce8528a40561fefb58925bd14d84f13778bc25fc2ec26adae42d5b085f940f6748903e56a3cfba369dfc82573b64d383193f607b09f696055be08a45b4cb05d1198db255b6269fc39f6623c4b1b9abc6a9dfcd81987f7cf3da49760ffea41bc87610b5ef0b34ee70d3926d1c1db9f9fe5c3908795e10bd1f27e4df22242eb3ebf2dec6d9fca1bbcf3aa33f779723fd7a72f6acbf3df1175fe590943c762e30c4703eafc6d8a9992506966db2d761c173b69d290b63b2218fa542e56e6a52369885145f14962b9fdf83d8a36d1eb2cf585f036eec36ec140b2f9cc7e9eddb3e76e7193cd436f4b1b86bbe8bac62e2a77461d1660b7c79a18f8affbdb437c08616f94d564ecd4472faafc8133ae211f52fa2cd51422b6f9fb4e5f560d7f387ab0698cd8fb989ec7f30196d2951e7e51c967bd6a46148240b0ea2a3404a2854765d5acd3584ae019ee6c150fcd201a1862242397485ed50bde02122d881c8607bc254e8a541e76f2952560ebb9404d5e0adc45a67d3e450dadd3b9a8b6d014517adcd0cc13c2bd8f8f197e64e21e1fefcdacd674562f83ec6138875b0d1c2ee4488ea54304c70512c96ef03f6ef51a354088dddca97c02cee8a84422d6cba73d9966790c14b7c29a259479c67a7686b4633581be73bb2838e7a898c1ee08ac300f3bd4fd8deb7c2def170780bdcdae971bc54ac1a06f9aaa632d99ab2fc435d2b6769e203950dee1dcbe33bef604fd2584a5b91cd26e8e5a7633ffa2151da9d91c377ea5b92ce8edaaf3cc92a294e8a782e0c5e1499a43902dd2c1f00b2e2f3b5f19336446f1eacec6e18adb1c6a33de4de0f5a0b8111d57ad0413a3a8337c842d4132aa87e687fa4e9b2a3e34c24af11b6cc7b4dc1ed50eae9d31bb1948845ef6ce22fd6f15966a459d8e0a64dfcf9a84352f3e34c69fe63a726baf8edcd433d111c51c3c98d5e955ac2f35d037997da7fc39b024c751353c4995ba69946877c0a58c93346324e1c125e4cf7a5756369ed170107062238f5f65724177eabb483b9f6daadde78778e8c84e273fff870108cbe2e310e6e5ae82a4b632a3c200ede905fe5d0c4457e5bae0e3e4dd83df12d0c416fd867223095d63748bdc24202e5e4dd7fdc0f82e460ee5eae84ad5a4360b68602a04dc20cf5f550e0b9ce0983cd62151bf4a2c0332cd6261515bbe955a4cb72c1f97e9cc77a9bdf21ceb77f8e6cd736dee623c0776eeba8b3cd2a1d83237eac88618864940ccc87d2308630f12afb5f48a4c34d02e417891e6feceeb11d56daca62606d17144af412cb31592641833e3546fcd4054e8cd10b2c983c85105582fa228208fd0d0d11dd3069e12072bf4faa87e26648bb659d563b941ea3c92851eabfdcef9937b92996db465cf7e69f4f9e7d782facd48eac156f138feddf4a131131049ecf63d247d7e8a429ea15efa64e06f463c73f7947e96241318ffc4ccad013c8aaed162d69767e1fff9e0bb791987e0bfb18b662485b7ed50de2743f6359d29d021f24c6f9379dd6ca275e7ff0ab98e00ff9abee2c308902557cec7c9da61a9085479e6dc454f54da52e971b41c2379364e25ae2757b9160a7009640fbdc6a0af82e0b2f9d1f302cabba9ef4d455c8085a770b3dcd87ff2f944756aa8313d1c8876dfdecd2ec7b95e108b046dac01d2dd0a19b647c7645ca4162969d958b729e8e101aa814896ad92bb5bc9fac957fd9d129fb0e5615028da04f5b6bc23dde77af325b1c9bee4215ef2d6d147c4ab623d26818d01127d4c6249f5d8988988cd44016fde3f2db3d9d0c96604831c79c134cdec1f965aed791222a2695e85f417b3befc309ba5cb461bf6eedcedfcffbb04d5793d492e544345c73b7bacaaf03725866fb9d61919b05b64a51f32dc2d824e995ce40fde45deae8518305f49011856a3310f75eae2d056b45fc9916b787e905149c7e04b913c9c51f4a35771598ec61af2cc54858e50aaf3324882f62060c3dfd72bb2d401ee8fe10fb4943cc69658868f82888c03f6f570d257c923d0a97c6c99d5baeac60e91981a1ab303998682c83b0fd6b10710f23a7a2c5e6f933ead13081b50d2d7b3059d00b349bbcb97b7430f1221fc8c89c3d72c9fb7104f0a0fc69ea24fcba79da9b1721a70e6e08d7f8c987d051460710b45fdedd8511ac7afac413c421bebca5246e72305f92a56c655232f93bf67159bb645ce7333886768b6e01ce31245b8f872cddf1876798d097f81b6887a1ef109addea13216dc02a93c7ad5b4cbb36345fa63d7af3b20820876ba5020414741e24eadd97258ab2546ba664a9c2eeca0d4bb5581de8ee7f8850ae108362160dc85e1a880c84af7b50865b4085f6ef82c7df868b0087369ba58ba3eb1b782ba14268703fd2cd86df4561b119abcc89dc3a0344076ff1b24b118f7a9e19430af6b8bb2b3a82d463d34dc782a4f96ba6379ae794e1103c6bb94d0dcc66e1f20ff1cf87ca59adc8cb8993ba461ecacedb7f89361f5db1032c2eec1805c51a32f0fb7204b1498e4053e2f8fded7f43b6ace51e9b4660a37f0a9ba5cf359c3eee7f95cab53d78b2cde86063a99007323560f9860c8016dab8fe45c75f682c41fbf168bd19f2e6381543684a312bbf042fb97c0ae6608e568da58d60d5e64a1b91629140f36a651e91f436327d87f45023ab3c647b2d81962dfae461dbceba5ca8fce513ee7e2e8bb78cfbff22d67a87f09cf9f422e6f48c75325ffdc42c6e8c1e7e457a9cab58d0536059312da032c9c4d2c6879dfdee33714fa54972cfd4edb3501de1f0caa1689ea19f92dd6f826a96dad0d10996d5b34a95550a775eb1f5b6dbdc8d9455220532514da967f80f22212eece597a8020565e66a1c46e38e1133c5ddd7e28a0a73119d5e5a13f745d725450cce08eb29e6d54ba0bf81168734916acd89973147691f73ea61b48b430e9e5cef043d5ee2b7a0eb5a6e4d7e938609bd6989771671cdb13754b7ff5c61e2076d277d92ad997d2888116a3e3c4911d5fcea02ee6496a57572023ba99d09508de43d1350098f788e8a57f42169143271a77b8f8c6caad2a539ac4ac1eda64f434dd8c5308675ae06eb2216157a252b3343d4fd563df02ccdc9f235e9c9c27322fd496bbf0a553af722da66cf74c88065fe70f02bd8571b50727be7c13a7cfcfb2b4b36cb3485d5e2cda4ea1756518d36e8638ec9d8e5de137573345312e84e508c1d0e88890ea92959f83ed3b243dba39fea9dba22c389c8c62c74969dafbe9b54848171208905de386348a2199db7998cbf53e17c9f03598ff1a8d7942bd8cd676d4fbc118ad1405c13ced452600bf691b89064850ec2b62579e55afc92e9e53a658caa8819c49acb35dec93fe081a91947d7896411e3d80a923231175e1cb407c7da80bbef5ff3af5085e7dfa8dca65d33ef72890731519ef18a22de658e5e5675773457341b1c33d57f3d0b12285d5c1f344c5acd2bc5538caa0528049b23152926a851bc9983112af0978a939e5d5e0336b2e8f8221138ab142e9bb8fbb26bc4a700f88fcd2393d902556c5987ccb92cb9f59261b416431c803eb83aaa1ae773ac494a1b0120e7e8df435a76c4cdbd09b3fecf68c04bdb7ae433b9ff2b948aabd624a6204c28b90ea47cc52271ced01f03b402e1b1cacfae61d31c6713cce099377c11d5ec78ba976b21e796ee56fd64b448bdc45ebca563f3db9ebf7bd81c7c1144cbbe011c03942eaee9b039914c2a88bda078e2cada88f018b70275dbabde952673ddd56b618a22c0f134d08abcf645049080006a6d306545ce6927c9dc920ab138af446b8f6794a6a3ce21b5b20b59e63e13fad4bc9c204739312a8562737bb7abcf36b7746ef1ff4a71419e9cd80a1d6b738d15edb91efef8623dbb7bd391f77a1da208978a357e1e67912190ea7821762eba369993ae79a4f8abe6ee3f12028a93746149812f09fafbbf3677346c3988c3286306ab16813cebe8b0baa193a97c959db82318f2130050ac1db6ac26b1bb14dd341602714402b338b75e4335e6c0445e1467b24c06ac300f2d9f583dad8cba1d7d4bf84f5f43a8fe25578b8120faab9444faba30ac29d41a6a1ec2b0676d2e5b0c6e8c8a9ceb01867f758eb7e08f6fb05de9d9c937edb380a00573fec087934daf035bfe84bb47ddfc7e1e9da0b5520629c31889a7793b107e1f8443f4aac13570fbd38fbcbf11edf3d9a1dfb2ec930315f688d748c4dc4ef1850251e352cb62c62c212f412ce51ef5908483943b1e089828e249f589cb5b14beda6f017580b34f80d6dafd2234fe9c083d14fdae0f319c301fb6b88d4fbb0ebad83a1b870a0a58b66f16200f03906c1daa56c250ccdbcc3a9545f77561f928aaf6be49991cbf2eb70eaa3091576fe1ba79875778b74822f047409a4b4f49ad269565ce32eabb4e913b4a834a5f1912acbbd4ea02ebc3c87dfd0a371cfb3becea7e2c5256d67e5f8ab178a14859dd52bdb5dbb18aed6bef1ea618db5349a94698b63b206f19fcf052eaf6552458979ec6f2fffdc4adafff5444447305cc4226473a1e7475fe4a9b0711167d37f6bf83e6f5dace4f3aac061fb08d346d13b6473f4fec29bb75a828c5e104d6b05653b55f9972d93f59b1add1b55bf1aecabf5207079006a3124faf27ae36629162787c4191617d6e0f86f8f68301aa8dd1bcf06ed905eea7a495b5138fdddd83978624d5c732220e4a9bbf39c5d9a58b45adfd8b28518e71524780eda0813f9a0a8e3177730c7e1c1be5ec38823481806136bfdc9bf683b57bcccaf6cb8b81b2b57bf503415a981f6981fe1a9ec868d196691cb704e8da571de48c3431f24049efab101b4819b6ec7155f438f10afc857e345bae0fb8dc26aa76f31393ff284fdbd966adbc8081cffb5b2d8a9b55f87772345fe68536342f7117b2f9c802589acb3b4518381965b53952cb841aac0de0d4796b2bd75f953234b5a5e417e28fedbe577052aa2ce4ca04597a6ebbebaf56d011704a795fe5d5aa25630fa04c896da6b0e004016eec61ee399904c94de962ba7ff8ae23b7744a5a44d0b662bcfd185ee92a068fd565e749be8f094d3440d3d164b126183998b1d9547524e58372ffd8063be63f525ab10c52fc284dc2a721ecd4bbde2fe97d17781cd9ac31ff8a01c99867754d8e9bade03f2e286ba9cc1aa9888e6fde0e6f7136323b915dbd004dbc1d8c91953e7ccfcea2a654b0451d8a51a2c9b241fdb6f526aba790cba706fc7486d4ab0dc485d7a2d71d57194d848ae79f308879df9bfa4cadd51ac6f1b6d7b4926ef3d084faeb080dbf10711d53faa2c34fa4bdc38f25774e057c25eac3885f76a64d24400f75538a304bb5790d65fc6b5bbca41b213a8eacb37f1233803e5aa55dd6841c705abbd9dc2e7effddaa6f56fae0e9b30eaee19045c416f7954f2346ef3a43c74206883f499c828b388c7abc294dc9967bbbb3d20b295280b13bfdd3a55502228c9272450ad0cc8f4e5d5f1ce52383db71cffb28b66b421a3503aa605dbbd8964f60d1e78d1fa7b9053408bb8418a78a2d17649599ff09d82aa2f9e34994c793b4a3b7485f5516fa8a3c1665636248c80d136d6ee1dc4e596edad9025ea7fe801b0ef0d605bb4267cd0f9be7ce7a0282465694ae276ad254ecc7ed8ebac48c5cf30467a4815c2a789c0e2e8fcdbf55aed37f33fe99d5fa461c032338a3730e566e9c3448eacbb2a8537ed2feaaa1546e0c04fef089fed6911af0cd4c6ea9f4d31bd7983a383c1cdd29765eafd112f09e4c51408aec7eafbd202fecbc401491113aa90c38e6fd3eb9ea9bd9019a9f38150b024b42981ed01ee46d6d4d18c765a8e3abc3a7c476bf700574a71d9935f98ec37c50188bc896ac96be8db4580ae1acdb1df46cbe1725ebf23ada3e099fd236d16d3dc11e7827e1ee9fb6c0e1452be9b72ebb09c748ae3705e3244d57ee7086ab9dd6306b81f1f1a6c825957be0d9b03dead4db0ff9638ff17065e94b02c9c2df51ae295719a8fcfb4eaa4ecf48415b854b63fdb0a8fbd40c03b91e1a4a65b24809679287f14e5a4f80a6d49b489c147c8fe1abb4f7ca0233147c9e240b76379c79bb9d8d12c0402b3ae9d58bf47b08bb9538a7ac3153e0916389d6b9cce830a0e683315352e521b5a68d7e799c3bf20932deec5a4f2a481cbd0164d5dfdc92531cf90cb3fd2955410129beceaa4e04b28dc9b3859d9807150b718c3a1e29c261bb96d787aebe6b00b26ae3fae388a6c88149e3a2190fcf71edced4faa911c3003540015</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回科技园</title>
      <link href="/2019/08/11/%E9%87%8D%E5%9B%9E%E6%AD%A6%E5%A4%A7%E7%A7%91%E6%8A%80%E5%9B%AD/"/>
      <url>/2019/08/11/%E9%87%8D%E5%9B%9E%E6%AD%A6%E5%A4%A7%E7%A7%91%E6%8A%80%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="b451090b4e78a9d8e0942fb111bc0878859e0b62746547dd226f1ce277230a82">305a832858cf8cef14f9d85cee8e5b9d3fe10307103af5ee275a8dd34365887a9e7036c7b975e73b6c75d0fecec5fb8e84ebc474ec340d30b3c3c8adf567607e9c30cd3b7447ea54f6aa7071454636651dcb28ac5936f3846208fc7c9d990082e7b9e271ea08f60df29781f2c65cd22cf511868cd6848c0dd2fbd0ffd4ef296f0c6ba1eeabf58b71d4a84c29348e9a20b656973bcd6f330632c0e11bfd05e3766af6ff02729f8ea3187f9e90a611015996a5a9977e3533a2fc51783095cc09b72a59899575bb165c6ce8fb9db7d2dfbbc96ec3d1490774489cac126ea3961b198ddaea145f4f5da097f40868f02e1d6b5a80e7f3912ea846ffd93a61a345a316ec519d54784d4cddedcec0ca77cc334aea0eb2c63746457d0c9c4b8d103fb8e6855538b75070010d8163d5b8c6c790e974529bef3d4a61f8a572515ae21fbbdbac2d196a431797445a23d52468a37ea3f70a584122723b248c86601d2aa3a2c7f472a169eae3665ff41395f24c3ae06c793bfbb575923df6eceb0025e29dc28713635fa605f7b5323ea356a493dd6141c202cf31a2f5550c595df2d350e78a496cd06cc98623684b6336549c773ac485eb746843072d1edeb0ddd21ec80cd26a92defbd8aec9c4414cb48f05bfb130a34f7e9f867c48a772d432e4d6e1999175aa7b2d599f734ff9afc868cfe0d804f4e7c110b6ba78cba6e11dff1476bb577259f1b222d0e550f3ebeecd68ba5ab32bf0dd0d83bd7997211a4bb5063d7cbbb261b7f1e634e8ca381b0257561c2da62f7edafa17e3f45c72e8e4fb05830e89dc285b154df1106e45e3b7f0f4a73881740cf8a3e753af75671f3765b2c3ba84ff3a763155d69af560c8d11919e90d9872dbe7d989fcf4237b6207bce3b73d15813b6b98d485237ad6d47bf53e8e9fbc2b410a8eedded7774fec06c55f30720e7eef17cd95071ebb2bc65f28c31c4019fc676212eafdfe89eb17cfd025af7fe9b6b8865250f76b9e8ddf320f2d3445025bb32ea2026be550ce4990be8a74f0ba5787ddc40f1a2fc6a88b083212e99a577260b5f5d21a65a5ef7249d3f106d9021709ccf4c1add94ad5d6805971b729a3a0ac895a9040cb699e8803fd4b51015ee45a7b44ce59f03b61c510fd8d652e66ad72feb07598f38feaf55390818a4198ed850fc0ff573b338fc77200c0ba8955019ec8348ca3a0d05ba18487d7afc57d53b26f9647fd961629962af0ea68d7307b2b9b542f4c834e2844246668c5750ec30d2aaa4ee1a375b9b90a6136622187abe538deb88500ab288dd98cda20be843b5de7ef30be20720795f6fe7b18613adc668c1c05aa8e357619c1fd3a0cde357f686c3e9a24ac007b1395ac9ffac0cc40cbf7e19f4b2fea92ec57b6711cf085043fac3afa99df70814a950a3747b5ea7ed6c6304d87528c79dffd452c62bc45c60546fd44eb17819cb8cc50d78d8ea716be9b5a9b8d2644c1891abd04ba4c4b586f0118bb2b4bade3f49585f75fb051e3e7526b6cb12de03873de7eb55d08c7f6a0fa033470960682272a850f0be3b2695dc2aa7707d0897a1ec007234050e17e0b53b14854439b8ab9a3262b105795cdff7911091f61aabf53dc987fe4d6b0f61d3692bfc6103b549987f7451ddb309a6571d1897cb8c4d921d473fff52d1f8e162e5843d14ced5061a5a0d50649ef9ea9b1b55e9191faee11d9d5e95cda0a37f495f298ad338ae371a87068798b675a70d790b19055f7466e7332143f83668b9a7290b05fdaf4d511635012be28c502ed3564a9a2cf26d2b75e8b48d4eff4ad9a2e7aa80a9b803de444e0e32a3933b57691cb8d3688c3c6e504f0548a81b1959983fb264db4bdacdb0b9cac4fd34afd075db114a748de682035573a77fe2ed4f46660dbcecb870804f0eb6ed21dda3391273b708738dd5a125e4ca4c1d37feb551c764dc8d84f089f0ff525e87d337afc5ee04f07ce7bad1a5cdf3c7ae29fb5e0ccdd9fd343762e84f61fac1b444358e4d5ead65920210f287c27b181ed20201b5bc10a487840a9a00059e09c61aad670651a27cbd4ca63d4b53fe528f967815039fd98a6be28da368f2b0b5af3b1d893efa6a0202cfe2a67a8c76076f39813fca668d120e80678a0e69c7221861f28897fa4a451692c2440b8a526f408482f888c92d93e875fb99a8bdd8cd4f8e5f6158c4206334af0f64bb4ea76b6376364e4a6a9b8d6eedfe6cfb17bb9c14796e7e88f78f23f57d80b08d9c4e83f9811e7cb7edfbcfdb9cf8a09866dc5d43390073869a250922706c3f5398c588275cd5bbbc9b2f0e3ffe77a9834a1439c0b65cd46252261f374e63880108a22bc1ca25eec38856999476b5342e80d6cc68bf9b604f3246b39235eea453068ca10f14450bbd97c8c0e608b30f803c5488e012d911ba05858745575e1950a6efb3527d1989d7d568d4588c5a2c1c9e97781a82fcf9224af4f30ca5b5599dbb1127ff66f621e86d2b81776dab8d74e158c7e1e110cd472e19057ddd308be7e55c81d9e67c9ab66ce40ada62f3ab7bae18550a039113967269ed0ed8675f5ecdfb09bacf8f3b5e14bb0e28b4f12ef1c0aa9687509de59f76db9d0b2f8cd90d1adc65ac827708a7ebcf786e67d8f5587741be1d4b9c34a4c131a353776c11104fd76a305e0b3aea942b9ca79b1e13791c14e9869f5d4ecef88fc7fd95cca103260da09f3c3231b887d26eddb7616dbd7886b38d53e2f049b0f9d0facdd3dfbf095336ce88282725a614f5914dd1801c2cd2fa7b5bba7a81a95c8dad17964fc924e5f19ca4b194ba8887d111c06906aaccc66014de3c4b19910d697a6b6921a6f1abaffc0de591a56c79bd0b24e80f26f7060ee2236749cd412d839d883e570b3ff37cc4e83d64feacf7e5b0821c32a735689466f964779ea5be2575b53c179a3243fa964aea39f6189b92e7c04adb56f99c9440b1ce65bcc6ad89ee37d8464ce9cdf70d824b05489a8a45f3464c08b2372df8dda3c9ca638f13ca2259ef0c409b5a76cf73e9b2a59c8382e0d02aa21abf2f52388cfc50027092d7671c983a251e4d90abf90c6bf9ef1db5e0905e5f5ee42dcfe69df9b52cda77b875bc9f1a3c9fd8cf658bf5a5240a30e515f314b68ebcaa87029b95a3154cb000b163b9513d07d13eb2cccc2d85164860f7f390648011ba76c44b81f92f96d7bcceee0cd17c0efaf3be08c8e3a44382ad902b63c534da2b4903a925e6b0b95a6437c32c7040be864726cd827f32658620188de0e7400e370e126862a6e2460d1f64976defac5f1797f3558bb0f792eeeb1b7230fa6223c1fd1722841ea0b131ac3af1f4974c4b9251a1e614cfae92a7af4047992c3291b715543a742522682f5b76b9489540e06cfec1b7b0672c30c1ad4277a997d18e8b92c2aa265dc26abed0e69901c6a250017213c43f9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
